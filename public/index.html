<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
	  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
  <title>Not-Hex-A</title>
	
<style>	  
	
#fixedText {
position: fixed;
top: 5vh;
right: 5vw;
z-index: 999;
background-color: blue;
color: white;
padding: 10px;
border-radius: 5px;
font-size: 2vw;
max-width: 90%; }
	
body {
margin: 0;
display: flex;
background-color: #0000FF; }
	
form {
text-align: center; }
#svg-container {
width: 100vw;
height: 100vh;
overflow: auto;
touch-action: pinch-zoom; }
	
#gameCanvas {
top: 0;
left: 0;
width: 0;
position: absolute;
display: none; }
	
#hexagonGroup {
top: 0;
left: 0;
width: 100vw;
height: 100vh;	
position: absolute;
z-index: 1;
display: none; }
	
#firstP {
top: 0;
left: 0;
width: 100vw;
height: 100vh;
background-color: #000000;
position: absolute;
z-index: 1;
display: none; }
	
#bluePoint { display: none; }
  
</style>
</head>

<body>

<form id="nameForm">
    <label for="playerName">Introduce tu nombre:</label>
    <input type="text" id="playerName" name="playerName" required>
    <button type="button" id="submitButton">Aceptar</button>
	<div id="cameraOptions">
	<label> <input type="radio" name="camera" value="1"> Opción 1 </label>
	<label> <input type="radio" name="camera" value="2"> Opción 2 </label>
	</div>	
</form>

<canvas id="gameCanvas" height="0" style="background-color: #ff0000;"> </canvas>

<div id="svg-container" ondblclick="preventZoom(event)"> </div>

<div id="fixedText"> </div>

<svg id="firstP" xmlns="http://www.w3.org/2000/svg">  
<g id="camera">
<g id="hexagonGroup">



</g> </g>




<!-- Este es un comentario en HTML

<rect x="10" y="30" width="100" height="20" fill="rgba(128, 128, 128, 0.3)"/>
  <text id="textLine1" x="20" y="40" fill="red">Texto 1</text>
  
  <!-- Cuadrado semi-transparente detrás del texto 2 -->
  <rect x="10" y="50" width="100" height="20" fill="rgba(128, 128, 128, 0.3)"/>
  <text id="textLine2" x="20" y="60" fill="blue">Texto 2</text>
  
  <!-- Cuadrado semi-transparente detrás del texto 3 -->
  <rect x="10" y="70" width="100" height="20" fill="rgba(128, 128, 128, 0.3)"/>
  <text id="textLine3" x="20" y="80" fill="green">Texto 3</text>
  
  <!-- Cuadrado semi-transparente detrás del texto 4 -->
  <rect x="10" y="90" width="100" height="20" fill="rgba(128, 128, 128, 0.3)"/>
  <text id="textLine4" x="20" y="100" fill="orange">Texto 4</text>
  
  <!-- Cuadrado semi-transparente detrás del texto 5 -->
  <rect x="10" y="110" width="100" height="20" fill="rgba(128, 128, 128, 0.3)"/>
  <text id="textLine5" x="20" y="120" fill="purple">Texto 5</text>


 -->



<text id="textLine1" x="20" y="40" fill="red">
  </text>
  <text id="textLine2" x="20" y="60" fill="blue">
  </text>
  <text id="textLine3" x="20" y="80" fill="green">
  </text>
  <text id="textLine4" x="20" y="100" fill="orange">
  </text>
  <text id="textLine5" x="20" y="120" fill="purple">
  </text>



<text id="textLine6" x="80%" y="40" fill="red">Points: 1018</text>

</svg>	
	
<circle id="bluePoint" cx="170" cy="170" r="8" fill="blue" />




<script src="/socket.io/socket.io.js"></script>
    	  
<script>  

// COMIENZA EL JUEGO !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// CLIENT /////////////////////////////////////////////////////////
	  
document.addEventListener('DOMContentLoaded', function () {
	
const nameForm = document.getElementById('nameForm');
const gameCanvas = document.getElementById('gameCanvas');
const canvas = document.getElementById('gameCanvas');
const context = canvas.getContext('2d');
const socket = io();
let NameSecure = '';
	
///CAM OPTIONS
let Camara = null;
document.getElementById('cameraOptions').addEventListener('change', function(event) {
const selectedValue = event.target.value;
if (selectedValue === '1') { Camara = 1;
} else if (selectedValue === '2') { Camara = 2; }
console.log('Camara:', Camara);
});	

// DESPUES DE INTRODUCIR EL NOMBRE !!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!//////////
	
document.getElementById('submitButton').addEventListener('click', function () {
	socket.on('connect_error', (error) => {
    	console.error('Error de conexión:', error); });
	const playerName = document.getElementById('playerName').value;
	console.log(`CLIENT EJEC. Name: ${playerName}`);
	NameSecure = playerName;
	//Ocultar el formulario y mostrar el canvas
	nameForm.style.display = 'none';
	gameCanvas.style.display = 'block';
	hexagonGroup.style.display = 'block';
	firstP.style.display = 'block';
	// ACTIVAR EL SERVIDOR
	socket.emit('playerNameEntered', playerName);
});

function preventZoom(event) {
	event.preventDefault();
}

const hexagonMap = [
    [ { direction: 'NE' },  { direction: 'E' }, { direction: 'SE' }, { direction: 'E' }, { direction: 'SE' }, { direction: 'E' }, { direction: 'SE' }, { direction: 'E' } ],
    [ { direction: 'NW' },  { direction: 'ES' }, { direction: 'E' }, { direction: 'ES' }, { direction: 'E' }, { direction: 'ES' }, { direction: 'E' }, { direction: 'ES' }, { direction: 'E' } ],
    [ { direction: 'NW' },   { direction: 'ES' }, { direction: 'E' }, { direction: 'ES' }, { direction: 'E' }, { direction: 'ES' }, { direction: 'E' }, { direction: 'ES' }, { direction: 'E' } ],
    [ { direction: 'SW' },   { direction: 'ES' }, { direction: 'E' }, { direction: 'ES' }, { direction: 'E' }, { direction: 'ES' }, { direction: 'E' }, { direction: 'ES' }, { direction: 'E' } ],
    // Repite el patrón de filas según sea necesario para tener 20 filas en total
];

//CREATE HEXAGON PANAL
createHexagons();

console.log('Camara:', Camara);	
	
//VARIABLES/////////////////////////////////////////////
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!/////
	
let randomX = 0;	
let randomY = 0;	
let inicialX = 0;
let inicialY = 0;
let connectedUsers = 0;
let isMoving = false
const players = {}; // Objeto para almacenar la información de los jugadores
const hexagonGroup = document.getElementById('hexagonGroup');
const firstP = document.getElementById('firstP');
const bluePoint = {id: socket.id, name: '', x: 170,  y: 170,  color: 'blue', };
let topplayers = [];
const svgWidth = document.documentElement.clientWidth;
const svgHeight = document.documentElement.clientHeight;
let initialCameraX = svgWidth / 2 ;
let initialCameraY = svgHeight / 2 ;
let currentCameraX3 = 0;
let currentCameraY3 = 0;
let currentCamera10 = 0;
let currentCameraY10 = 0;
const camera = document.getElementById('camera');
let currentCameraX4 = 0;	
let currentCameraY4 = 0;	
let textLine1 = document.getElementById('textLine1');
let textLine2 = document.getElementById('textLine2');
let textLine3 = document.getElementById('textLine3');
let textLine4 = document.getElementById('textLine4');
let textLine5 = document.getElementById('textLine5');


let textLine6 = document.getElementById('textLine6');


function addPlayer(nombre, puntos, color) {
	const nuevoJugador = {
	nombre: nombre,
	puntos: puntos,
	color: color
	};
	topplayers.push(nuevoJugador);
}

//CIRCULO AZUL DEFINIDO
const bluePointElement = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    bluePointElement.setAttribute('id', bluePoint.id);
    bluePointElement.setAttribute('r', '8');
    bluePointElement.setAttribute('fill', bluePoint.color);
    bluePointElement.setAttribute('cx', bluePoint.x);
    bluePointElement.setAttribute('cy', bluePoint.y);

let bX = 0;
let bY = 0;

/////////////////////////////////////////////////////////////////////

//CLICK LISTENER HEAGONGROUP!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
firstP.addEventListener('click', function (event) {
	//console.log('HEXAGON GROUP LOG');
	const mouseX = event.clientX - firstP.getBoundingClientRect().left;
        const mouseY = event.clientY - firstP.getBoundingClientRect().top;
	
	moveBluePoint(mouseX, mouseY);
});

//CONNECTED USERS////////////////////////////////
///////////////////////////////////////////////// 
	
//SOCKET.ON SIGNIFICA QUE ESTA ESCUCHANDO AL SERVIDOR. Son datos que vienen del servidor.
  socket.on('userCount', function (count) {
    connectedUsers = count;
    drawUserCount(); // Llamar a la función para actualizar el texto en el canvas
  });
  function drawUserCount() {
    context.fillStyle = 'black';
    context.font = '16px Arial';
    context.fillText(`Usuarios conectados: ${connectedUsers}`, 10, 5);
  }	

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////	
//IN ORDER FUNCIONTS OF GAME
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//IN ORDER FUNCIONTS OF GAME
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
//1. CREATE HEXAGONS///////////////////////////!!!!!!!!
/////////////////////////////////////////////////!!!!!!//

function createHexagons(callback) {
const hexagonGroup = document.getElementById('hexagonGroup');
const hexagonSize = 50;
const numRows = hexagonMap.length;
const numCols = hexagonMap[0].length;
const hexWidth = hexagonSize * Math.sqrt(3);
const hexHeight = hexagonSize * Math.sqrt(3);
let minX = Infinity; let maxX = -Infinity;
let minY = Infinity; let maxY = -Infinity;
for (let row = 0; row < numRows; row++) {
for (let col = 0; col < numCols; col++) {
const x = col * (hexWidth * 0.87);
const y = row * hexHeight + (col % 2 === 1 ? hexHeight / 2 : 0);
minX = Math.min(minX, x); maxX = Math.max(maxX, x);
minY = Math.min(minY, y); maxY = Math.max(maxY, y);
const hexagon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
hexagon.setAttribute('points', getHexagonPoints(x, y, hexagonSize));
hexagon.setAttribute('fill', 'none');
hexagon.setAttribute('stroke', 'gray');
hexagon.setAttribute('stroke-width', '2');
// Accede al mapa de hexágonos para obtener la dirección
const direction = hexagonMap[row][col].direction;
hexagon.addEventListener('click', function() {
console.log(`Hexágono en (${row}, ${col}) con dirección ${direction} clickeado.`);
});
hexagonGroup.appendChild(hexagon);
} }
const mapWidth = maxX - minX + hexWidth;
const mapHeight = maxY - minY + hexHeight;
console.log('Ancho total del mapa hexagonal:', mapWidth);
console.log('Altura total del mapa hexagonal:', mapHeight);
if (callback) {
callback(); }
}
createHexagons(function() {
console.log("createHexagons end");

socket.emit('dibujarVerdes', 'numero');
	
});
	
//2. GET HEXAGON POINTS///////////////////////////!!!!!!
///////////////////////////////////////////////!!!!!!!!!
	
function getHexagonPoints(x, y, size) {
const points = [];
for (let i = 0; i < 6; i++) {
const angle = (2 * Math.PI / 6) * i;
const pointX = x + size * Math.cos(angle);
const pointY = y + size * Math.sin(angle);
const coordinate = `${pointX},${pointY}`;   
console.log(`Coordenada: (${coordinate})`); 
// Imprime la coordenada en consola
points.push(coordinate);
} return points.join(' ');
}

	
//4. CALCULATE HEXAGON VERTEX!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////	

const hexagonVertices = [];
function calculateHexagonVertices() {
const hexagons = document.querySelectorAll('#hexagonGroup polygon');
hexagons.forEach(hexagon => {
const points = hexagon.getAttribute('points').split(' ');
const vertices = [];
// Iterar sobre los vértices del hexágono
for (let i = 0; i < points.length; i++) {
const [x, y] = points[i].split(',').map(Number);
vertices.push({ x, y }); }
hexagonVertices.push(vertices); });
// Imprimir las coordenadas de los vértices en la consola
hexagonVertices.forEach((vertices, hexIndex) => {
//console.log(`Hexágono ${hexIndex + 1}:`);
vertices.forEach((vertex, index) => {
//console.log(`Vértice ${index + 1}: (${vertex.x}, ${vertex.y})`);
});});
}
calculateHexagonVertices();	
console.log("Longitud de hexagonVertices:", hexagonVertices.length);
function printRandomValue(min, max) {
	const randomValue = Math.floor(Math.random() * (max - min + 1)) + min;
	return randomValue;
}	
let randomC = printRandomValue(1,  hexagonVertices.length  );
let randomC6 = printRandomValue(0, 5 );
randomX = hexagonVertices[randomC][randomC6].x;
randomY = hexagonVertices[randomC][randomC6].y;
console.log("RandomHex:", randomC);
console.log("Elemento de hexagonVertices:", hexagonVertices[randomC][randomC6]);

//RANDOM X e Y for SERVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
function newRandomForServer() {
	const coordinatesR = [];
	coordinatesR.push({ x: randomX, y: randomY });
	console.log(`CoordsR: ${randomX},${randomY}`);
	socket.emit('sendCoordinatesR', coordinatesR);	
}	

//5. ASIGN COLOR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
socket.on('assignColor', function (playerName) {
console.log('SOCKET ASSIGN COLOR');
socket.emit('updatePlayersRequest');
//X e Y random for Player al principio	
newRandomForServer();
});	

//6. UPDATE TOP PLAYERS 2 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////	

socket.on('updatePlayers2', function (updatedPlayers2) {
console.log('SOCKET UPDATE PLAYERS 2');
topplayers = [];
//Iterar sobre el objeto de jugadores y actualizar la información
for (const playerId in updatedPlayers2) {
const player = updatedPlayers2[playerId];
//LOGS		
console.log(`PLAYER2: ${playerId}, ${player.x}, ${player.y}, ${player.nombre},${player.color},${player.puntos}`);
addPlayer(player.nombre, player.puntos, player.color);

if(NameSecure === player.nombre){


textLine6.textContent = `Points: ${player.puntos};
textLine6.style.fill = player.color;

initialCameraX = svgWidth / 2 - player.x;
initialCameraY = svgHeight / 2 - player.y  ;
//console.log('Coord circ:', initialCameraX, initialCameraY);  
//bluePointElement.setAttribute('cx', player.x);
//bluePointElement.setAttribute('cy', player.y);
bX = player.x;
bY = player.y;
camera.setAttribute('transform', `translate(${initialCameraX}, ${initialCameraY})`);
console.log('R. Numbers:', randomX, randomY);  
inicialX = player.x;
inicialY = player.y;
findAndMarkClosestVertices();
}
	
}

const topPlayers = getTopPlayers();
textLine1.textContent = topPlayers.length >= 1 ? `#1 ${topPlayers[0].nombre}: ${topPlayers[0].puntos}` : '';
if (topPlayers[0] && topPlayers[0].color) { textLine1.style.fill = topPlayers[0].color; } else {}
textLine2.textContent = topPlayers.length >= 2 ? `#2 ${topPlayers[1].nombre}: ${topPlayers[1].puntos}` : '';
if (topPlayers[1] && topPlayers[1].color) {textLine2.style.fill = topPlayers[1].color; } else {}
textLine3.textContent = topPlayers.length >= 3 ? `#3 ${topPlayers[2].nombre}: ${topPlayers[2].puntos}` : '';
if (topPlayers[2] && topPlayers[2].color) {textLine3.style.fill = topPlayers[2].color; } else {}
textLine4.textContent = topPlayers.length >= 4 ? `#4 ${topPlayers[3].nombre}: ${topPlayers[3].puntos}` : '';
if (topPlayers[3] && topPlayers[3].color) {textLine4.style.fill = topPlayers[3].color; } else {}
textLine5.textContent = topPlayers.length >= 5 ? `#5 ${topPlayers[4].nombre}: ${topPlayers[4].puntos}` : '';
if (topPlayers[4] && topPlayers[4].color) {textLine5.style.fill = topPlayers[4].color; } else {}






});	

//7. GET TOP PLAYERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
function getTopPlayers() {
const sortedPlayers = topplayers.sort((a, b) => b.puntos - a.puntos);
const topPlayersx = sortedPlayers.slice(0, 5);
topPlayersx.forEach(topplayer => { });
return topPlayersx;
}	

//8. GENERA CIRCULOS VERDES DEL SERVER !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////

let greenCircles = [];
let greenCircles2 = [];
// Manejar el evento 'greenCirclesGenerated' para actualizar los círculos verdes
socket.on('greenCirclesGenerated', (circles) => {
console.log('GREEN CIRCLES GENERATED.');
greenCircles = [];
greenCircles2 = [];
//console.log('CIRLES PUSH:', circles);
greenCircles.push(...circles);
//console.log(`GreenCircles LENGTH: ${greenCircles.length}:`);
generateGreenCircles();
});	
	
function generateGreenCircles() {
console.log('GENERATE GREEN CIRCLES 2.');
const svg = document.querySelector('svg');
const hexagons = document.querySelectorAll('#hexagonGroup polygon');
// Borra los círculos verdes existentes
document.querySelectorAll('circle[fill="green"]').forEach(circle => {
circle.parentNode.removeChild(circle);
});
let i = 0;
// Dibuja los círculos verdes en las coordenadas recibidas del servidor
greenCircles.forEach(({ x, y, z }) => {
	i+=1;
console.log(`${i}: ${x}, ${y}, ${z}`);
const greenCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
greenCircle.setAttribute('cx', x);
greenCircle.setAttribute('cy', y);
greenCircle.setAttribute('r', '8');
greenCircle.setAttribute('fill', 'green');
greenCircle.setAttribute('id', 'greenCircle_' + z); // Asignar un ID único
//svg.appendChild(greenCircle);
const cameraGroup = document.getElementById('camera'); 
cameraGroup.appendChild(greenCircle);
//ANIMACION CIRCULO VERDE
anime({ targets: greenCircle, r: 6,
duration: 1000, easing: 'easeInOutSine',
direction: 'alternate', loop: true });

});

greenCircles.forEach((circle, index) => {
    console.log(`Círculo ${index + 1}: x = ${circle.x}, y = ${circle.y}, z = ${circle.z}`);
});
	
}

//9. UPDATE PLAYERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
socket.on('updatePlayers', function (updatedPlayers) {
console.log('SOCKET UPDATE PLAYERS');
//Iterar sobre el objeto de jugadores y actualizar la información
for (const playerId in updatedPlayers) {
const player = updatedPlayers[playerId];

//PLAYER ELEMENT 
const existingPlayerElement = document.getElementById(playerId);
if (existingPlayerElement) {
	
existingPlayerElement.setAttribute('cx', player.x);
existingPlayerElement.setAttribute('cy', player.y);
const radius = parseFloat(existingPlayerElement.getAttribute('r')); // Convertir a número
const ptsf = parseFloat(player.puntos); 
const sizeCalc = (0.2 * ptsf) + 9;
existingPlayerElement.setAttribute('r', sizeCalc);

} else {		

const playerElement = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
const ptsf = parseFloat(player.puntos); 
const sizeCalc = (0.2 * ptsf) + 9;	
playerElement.setAttribute('id', playerId);
playerElement.setAttribute('r', sizeCalc);
playerElement.setAttribute('fill', player.color);
playerElement.setAttribute('cx', player.x);
playerElement.setAttribute('cy', player.y);

if(playerId !== socket.id) {
// Agregar atributo de jugador al círculo
playerElement.setAttribute('data-player-id', 'jugador'); 
}

hexagonGroup.appendChild(playerElement);	
}

//TEXT ELEMENT
const existingTextElement = document.getElementById(playerId + '-name');
if (existingTextElement) {
	existingTextElement.setAttribute('x', player.x);
	existingTextElement.setAttribute('y', player.y - 8);
	existingTextElement.textContent = player.nombre + ' ('+ player.puntos + ')';
} else {
	const textElement2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
	textElement2.setAttribute('id', playerId + '-name');
	textElement2.setAttribute('x', player.x);
	textElement2.setAttribute('y', player.y - 10);
	textElement2.setAttribute('text-anchor', 'middle');
	textElement2.setAttribute('fill', 'green');
	textElement2.setAttribute('font-size', '16px');
	textElement2.textContent = player.nombre + ' ('+ player.puntos + ')';
	hexagonGroup.appendChild(textElement2);
	}
}
});

//WHEN MOVE FUNCTIONS```````````````````````````````````````````````````-------------------------------------------------
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!-------------------------------------------------
//WHEN MOVE FUNCTIONS```````````````````````````````````````````````````-------------------------------------------------
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!-------------------------------------------------
//WHEN MOVE FUNCTIONS```````````````````````````````````````````````````-------------------------------------------------
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!-------------------------------------------------
//WHEN MOVE FUNCTIONS```````````````````````````````````````````````````-------------------------------------------------
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!-------------------------------------------------

//1. MOVE BLUE POINT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////////
	
function moveBluePoint( clickX, clickY ) {

const circles = document.querySelectorAll('circle[data-player-id="jugador"]');

circles.forEach((circle, index) => {
    console.log(`!!!!!!!!!!!Círculo ${index + 1}:`);
    console.log(circle); // Esto imprimirá toda la información del círculo en la consola
});

//CAMARA/////////////////////
const transformAttribute = camera.getAttribute('transform');
const match = transformAttribute.match(/translate\(([^,]+),([^,]+)\)/);
if (match) {
currentCameraX4 = parseFloat(match[1]);
currentCameraY4 = parseFloat(match[2]);
//console.log('Coordenadas cámara:', currentCameraX4, currentCameraY4);  
} else { console.error('No cámara.'); }
//CAMARA END/////////////////////
	
if (!isMoving) { 
console.log('/////Move Player//////')
isMoving = true;  
drawUserCount();

const closestGreenVertex = findClosestGreenVertexToClick(clickX - currentCameraX4, clickY - currentCameraY4); 
//console.log('Vértice cercano: ', closestGreenVertex.x, closestGreenVertex.y); 
animateBluePoint(closestGreenVertex.x, closestGreenVertex.y);
		
}
	
}	

//2. FIND CLOSES VERTEX TO CLICK!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////

function findClosestGreenVertexToClick(x, y) {
const greenVertices = document.querySelectorAll('circle[fill="red"]');
let closestVertex = null; let minDistance = Infinity;
greenVertices.forEach((greenVertex) => {
const x1 = parseFloat(greenVertex.getAttribute('cx')) - currentCameraX3; 
const y1 = parseFloat(greenVertex.getAttribute('cy')) - currentCameraY3; 
const distance = pointToPointDistance2(x, y, x1, y1);
if (distance < minDistance) {
minDistance = distance; closestVertex = { x: x1, y: y1 }; }
});
return closestVertex;
}	
function pointToPointDistance2(x1, y1, x2, y2) {
const dx = x1 - x2;
const dy = y1 - y2;
return Math.sqrt(dx * dx + dy * dy);
}

//3. ANIMATE BLUE POINT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
/////////////////////////////////////////////////////////////////////////////	

function animateBluePoint(destinationX, destinationY) {
console.log('1. Animate Blue Point');
//const startX = parseFloat(bluePointElement.getAttribute('cx'));
//const startY = parseFloat(bluePointElement.getAttribute('cy'));
const startX = bX;
const startY = bY;
const startTime = performance.now();
const duration = 50; // 1 seg
function update() {
const currentTime = performance.now();
const elapsed = currentTime - startTime;
const progress = Math.min(elapsed / duration, 1);
const newX = startX + progress * (destinationX - startX);
const newY = startY + progress * (destinationY - startY);
		
//bluePointElement.setAttribute('cx', newX);
//bluePointElement.setAttribute('cy', newY);
bX = newX;
bY = newY;	

if (progress < 1) { requestAnimationFrame(update);
} else {
// Animación completada, emitir datos al servidor
socket.emit('animationData', { start: { x: startX, y: startY }, end: { x: newX, y: newY } });
// Supongamos que newPosition es un objeto con las nuevas coordenadas
const newPosition = { x:  newX , y: newY };
socket.emit('updatePosition', newPosition);
inicialX = newX; inicialY = newY;
	
}
} requestAnimationFrame(update);
}		

//4. SOCKET ANIMATE BLUE POINT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
socket.on('animateBluePoint', function (animationData) {
//console.log('SOCKET ANIMATE BLUE POINT');
const playerId = animationData.playerId;
const data = animationData.data;
const txt = animationData.playerName;
// Encuentra el círculo correspondiente al jugador
const playerElement = document.getElementById(playerId);
const textElement2 = document.getElementById(playerId + '-name');

animateCircleLocally(playerElement, data.start, data.end, playerId);
animateNameLocally(textElement2, data.start, data.end);

//FINISCHED ANIMATE CIRCLE LOCALLY !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	
animateCircleLocally(playerElement, data.start, data.end, playerId, function() {
	console.log('La animación ha terminado');
	findAndMarkClosestVertices();
	isMoving = false;
	});
});	


//5. ANIMATE CIRCLE LOCALLY !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
			  
function animateCircleLocally(circleElement, start, end, playerId, callback) {
//console.log('ANIMATE CIRCLE LOCALLY');
const duration = 200;
const startTime = performance.now();
function update() {
const currentTime = performance.now();
const progress = Math.min((currentTime - startTime) / duration, 1);
const newX = start.x + progress * (end.x - start.x);
const newY = start.y + progress * (end.y - start.y);
		
circleElement.setAttribute('cx', newX);
circleElement.setAttribute('cy', newY);

////CAMERA MOVEMENT
if (socket.id===playerId) {
	const newXCam = svgWidth / 2 - newX;
	const newYCam = svgHeight / 2 - newY;	
	camera.setAttribute('transform', `translate(${newXCam}, ${newYCam})`);

// Obtener el radio del círculo como una cadena de texto
const radiusAsString = circleElement.getAttribute('r');
// Convertir la cadena a un número flotante (float)
const radius = parseFloat(radiusAsString);
detectarColisiones(circleElement);
detectarColisionesRectangulares(newX, newY, radius, greenCircles);
}	
////END CAMERA MOVEMENT
		
if (progress < 1) { requestAnimationFrame(update); } 
else {
// La animación ha terminado
if (typeof callback === 'function') { callback(); } 	
}	
} requestAnimationFrame(update);
	
}

	
//6. ANIMATE TEXT NAME !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
function animateNameLocally(circleElement, start, end) {
//console.log('ANIMATE TEXT LOCALLY');
const duration = 100;
const startTime = performance.now();
function update() {
const currentTime = performance.now();
const progress = Math.min((currentTime - startTime) / duration, 1);
const newX = start.x + progress * (end.x - start.x);
const newY = start.y + progress * (end.y - start.y);
	
circleElement.setAttribute('x', newX);
circleElement.setAttribute('y', newY - 8);

if (progress < 1) {
requestAnimationFrame(update); } }
requestAnimationFrame(update);
	
}	

//7. MARK RED VERTEX NEAR!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
function findAndMarkClosestVertices() {
clearAllGreenCircles();
const currentX = inicialX - currentCameraX3;
const currentY = inicialY - currentCameraY3;
// Encuentra los vértices en un radio de 60 pixeles
const closestVertices = findVerticesInRadius(currentX, currentY, 60);
// Agrega un círculo verde en cada vértice encontrado
closestVertices.forEach((vertex) => {
markVertexWithGreenCircle(vertex.x + currentCameraX3, vertex.y + currentCameraY3);
});
}
	
function clearAllGreenCircles() {
const svg = document.querySelector('svg');
const greenCircles = document.querySelectorAll('circle[fill="red"]');
greenCircles.forEach((greenCircle) => { 
const cameraGroup = document.getElementById('camera');
cameraGroup.removeChild(greenCircle); }); 
}	
	
function findVerticesInRadius(x, y, radius) {
const hexagons = document.querySelectorAll('#hexagonGroup polygon');
const result = [];
hexagons.forEach((hexagon) => {
const points = hexagon.getAttribute('points').split(' ');
// Iteramos sobre los vértices del hexágono
for (let i = 0; i < points.length; i++) {
const [x1, y1] = points[i].split(',').map(Number);
// Calculamos la distancia entre el punto azul y el vértice
const distance = pointToPointDistance2(x, y, x1, y1);
// Agregamos el vértice si está dentro del radio especificado
if (distance < radius) {
result.push({ x: x1, y: y1 }); } } });
return result;
}

function markVertexWithGreenCircle(x, y) { 
const svg = document.querySelector('svg'); 
const greenCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); 
greenCircle.setAttribute('cx', x); 
greenCircle.setAttribute('cy', y); 
greenCircle.setAttribute('r', '3'); 
greenCircle.setAttribute('fill', 'red');
//console.log(`Verde agreg: (${x}, ${y}) marcado con círculo rojo.`);
const cameraGroup = document.getElementById('camera'); cameraGroup.appendChild(greenCircle);
}


////////////////////////////////////////////////////////////	
//YELLOW POINTS CERCA DE LINEAS !!!!!!!!!!!!!!!!!!
////////////////////////////////////////////////////////////
	
// Función para calcular las líneas que forman los hexágonos
function calculateHexagonLines() {
const hexagons = document.querySelectorAll('#hexagonGroup polygon');
const hexagonLines = [];
hexagons.forEach(hexagon => {
const points = hexagon.getAttribute('points').split(' ');
// Iterar sobre los vértices del hexágono
for (let i = 0; i < points.length; i++) {
const [x1, y1] = points[i].split(',').map(Number);
const [x2, y2] = points[(i + 1) % points.length].split(',').map(Number);
hexagonLines.push({ x1, y1, x2, y2 }); } });
return hexagonLines;
}	
// Función para dibujar 100 puntos amarillos aleatorios en las líneas de los hexágonos
function drawRandomYellowPointsOnHexLines() {
const svg = document.querySelector('svg');
const hexagonLines = calculateHexagonLines();
for (let i = 0; i < 100; i++) {
// Elegir aleatoriamente una línea de los hexágonos
const randomLine = hexagonLines[Math.floor(Math.random() * hexagonLines.length)];
// Calcular una posición aleatoria a lo largo de la línea
const randomX = Math.random() * (randomLine.x2 - randomLine.x1) + randomLine.x1;
const randomY = Math.random() * (randomLine.y2 - randomLine.y1) + randomLine.y1;
// Crear un círculo amarillo en la posición aleatoria
const yellowDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
yellowDot.setAttribute('cx', randomX); yellowDot.setAttribute('cy', randomY);
yellowDot.setAttribute('r', '2'); yellowDot.setAttribute('fill', 'yellow');
const cameraGroup = document.getElementById('camera'); cameraGroup.appendChild(yellowDot); }
}
//drawRandomYellowPointsOnHexLines();	


//DETECTAR COLISION CON CIRCULOS VERDES !!!!!!!!!!!!!!!!!!
////////////////////////////////////////////////////////////

function detectarColisionesRectangulares(blueX, blueY, blueRadius, greenCircles) {
for (const circle of greenCircles) {
	
const greenX = circle.x; 
const greenY = circle.y;
const greenRadius = 9;
const greenIndex = circle.z;
	
// Calcular las coordenadas de los rectángulos delimitadores
const blueBoundingBox = {
x1: blueX - blueRadius, y1: blueY - blueRadius,
x2: blueX + blueRadius, y2: blueY + blueRadius };
const greenBoundingBox = {
x1: greenX - greenRadius, y1: greenY - greenRadius,
x2: greenX + greenRadius, y2: greenY + greenRadius };

// Verificar la colisión entre los rectángulos delimitadores
if (blueBoundingBox.x1 < greenBoundingBox.x2 && blueBoundingBox.x2 > greenBoundingBox.x1 &&
blueBoundingBox.y1 < greenBoundingBox.y2 && blueBoundingBox.y2 > greenBoundingBox.y1) {

const circleToRemoveC = document.getElementById('greenCircle_'+greenIndex);
console.log(`COLISION Z: ${greenIndex}:`);			
console.log(`REMOVE !!!!!!`, circleToRemoveC);

if (circleToRemoveC) {	
circleToRemoveC.parentNode.removeChild(circleToRemoveC);
var indice = greenCircles.findIndex(function(elemento) {
    return elemento.z === circle.z;
});
if (indice !== -1) {
console.log("Elemento eliminado correctamente", greenCircles[indice]);
greenCircles.splice(indice, 1);
socket.emit('greenCircleEaten');
socket.emit('collisionWithGreenCircle2', circle.z, indice, socket.id);

} else {
console.log("No se encontró ningún elemento con z igual a 10");
}	
}	

// Colisión detectada
return true;
}
}
//console.log(`NO COLISION`);
// No hay colisión
return false;
}


//MANDAR COLISION A TODOS ELIMINAR CIRCULO VERDE !!!!!!!!!!!!!!!!!!
////////////////////////////////////////////////////////////	

socket.on('greenCircleCollision', (collisionIndex, indexToRemove, comproid) => {

if (comproid !== socket.id) {
console.log(`BORRADOR ACTIVADO!!!`);	
	
const circleToRemoveC = document.getElementById('greenCircle_'+collisionIndex);
console.log(`COLISION Z2: ${collisionIndex}:`);			
console.log(`REMOVE2 !!!!!!`, circleToRemoveC);

if (circleToRemoveC) {	
circleToRemoveC.parentNode.removeChild(circleToRemoveC);
let indice = greenCircles.findIndex(function(elemento) {
    return elemento.z === collisionIndex;
});
if (indice !== -1) {
console.log("Elemento eliminado correctamente", greenCircles[indice]);
greenCircles.splice(indice, 1);

} else {
console.log("No se encontró ningún elemento con z igual a 10");
}	
}	
	
}
	
});

//////////////////
//////////////////	

//8. DETECTAR COLISION !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
function detectarColisiones(playerElement) {
		
document.querySelectorAll('circle[data-player-id]').forEach((otherCircle) => {
const playerIdN = otherCircle.getAttribute('id');

const blueRadius = parseFloat(playerElement.getAttribute('r')); 
const greenRadius = parseFloat(otherCircle.getAttribute('r'));
	
const blueX = parseFloat(playerElement.getAttribute('cx'));
const blueY = parseFloat(playerElement.getAttribute('cy'));	
const greenX = parseFloat(otherCircle.getAttribute('cx'));
const greenY = parseFloat(otherCircle.getAttribute('cy'));

// Calcular las coordenadas de los cuadros delimitadores

const blueBoundingBox = {
x1: blueX - blueRadius, y1: blueY - blueRadius,
x2: blueX + blueRadius, y2: blueY + blueRadius };

const greenBoundingBox = {
x1: greenX - greenRadius, y1: greenY - greenRadius,
x2: greenX + greenRadius, y2: greenY + greenRadius};
	
// Verificar la colisión entre los cuadros delimitadores
if (blueBoundingBox.x1 < greenBoundingBox.x2 &&
blueBoundingBox.x2 > greenBoundingBox.x1 &&
blueBoundingBox.y1 < greenBoundingBox.y2 &&
blueBoundingBox.y2 > greenBoundingBox.y1 ) {

if (blueRadius > greenRadius){ 
console.log(`ID Jugador: (${socket.id}), (${blueRadius})`);
console.log(`ID Enemigo: (${playerIdN}), (${greenRadius})`); 

//console.log(`Radio Jugador:`, blueRadius); 
//console.log(`Radio Enemigo:`, greenRadius); 
	
console.log(`HAS COMIDO AL OTRO JUGADOR`); 

socket.emit('eliminarJugador', playerIdN);
	
}else if (blueRadius < greenRadius){
console.log(`ID Jugador: (${socket.id}), (${blueRadius})`);
console.log(`ID Enemigo: (${playerIdN}), (${greenRadius})`); 

//console.log(`Radio Jugador:`, blueRadius); 
//console.log(`Radio Enemigo:`, greenRadius); 
	
console.log(`GAME OVER`); 
}

}

});
	
console.log('La detección de colisiones ha terminado.');
}	

//ELIMINAR JUGADOR DE TODOS CLIENTES CUANDO COLISION !!!!!!!!!!!!!!!!!!
////////////////////////////////////////////////////////////		

socket.on('eliminarJugadorEnCliente', (playerIdN) => {

var circulo = document.getElementById(playerIdN);
if (circulo) {
circulo.parentNode.removeChild(circulo);
} else {
    console.log("El círculo con el ID especificado no fue encontrado.");
}

if (playerIdN===socket.id){
gameCanvas.style.display = 'none';
hexagonGroup.style.display = 'none';
}
	
console.log("ELIMINAR JUGADOR", playerIdN );
	
});	


/////////////////////////////////////////////////////////////
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
//END DOM	 
});
//END DOM
	
</script>
  
</body>
</html>
