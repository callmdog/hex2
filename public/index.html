<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<title>Not-Hex-A</title>
<!-- ESTILOS CSS ARCHIVO !!!!!!!!! -->	
<link rel="stylesheet" href="styles.css">
<style>
</style>	
	
</head>

<!-- BODY HTML !!!!!!!!! -->	
<!-- BODY HTML !!!!!!!!! -->	
<!-- BODY HTML !!!!!!!!! -->	
	
<body class="no-select">

<!-- GAME OVER RETRY BOX !!!!!!!!! -->	
<!-- GAME OVER RETRY BOX !!!!!!!!! -->		
<!-- GAME OVER RETRY BOX !!!!!!!!! -->			
<div id="retryBox">
	<div id="contentR">	
		<div id="logoImg">	
		<img id="topImage" src="hexicon.png" alt="Hex3" class="no-select">
		</div>	
		<h2>Game Over</h2>
		<p id="points">Points: 1018</p>
		<button id="retryButton">Retry</button>
	</div> 
</div>	

<div class="container">

<!-- PAINT CANVAS BOX !!!!!!!!! -->
<!-- PAINT CANVAS BOX !!!!!!!!! -->		
<!-- PAINT CANVAS BOX !!!!!!!!! -->			
<div id="paintBox">	
	<div id="canvasContainer">
	<svg id="svgCanvas" width="100%" height="100%">
	<rect width="100%" height="100%" fill="white"/>
	</svg>
	</div>
	<input type="color" id="colorPicker" value="#000000">
	<input type="range" id="brushSize" min="1" max="20" value="2">
	<button id="undoButton">&#x21A9; Deshacer</button>
	<button id="redoButton">Rehacer &#x21AA;</button>
	<button id="fillButton">Rellenar</button>
	<button id="clearButton">Limpiar</button>
	<!-- Agrega botones para el selector de formas -->
	<button class="shapeButton" data-shape="line">Línea</button>
	<button class="shapeButton" data-shape="circle">Círculo</button>
	<button class="shapeButton" data-shape="rectangle">Rectángulo</button>
	<button class="shapeButton" data-shape="triangle">Triángulo</button>	
</div>
<!-- END PAINT CANVAS BOX !!!!!!!!! -->			



<!-- SKIN BOX !!!!!!!!! -->
<!-- SKIN BOX !!!!!!!!! -->		
<!-- SKIN BOX !!!!!!!!! -->
<div id="selectSkin">	
	<h2>Select your skin</h2>
	<div id="selectedSkin">	
	<div class="skin"></div>
        <div class="skin"></div>
        <div class="skin"></div>
        <div class="skin"></div>
        <div class="skin"></div>
        <div class="skin"></div>
        <div class="skin"></div>
        <div class="skin"></div>
        <div class="skin"></div>
        <div class="skin"></div>
        <div class="skin"></div>
        <div class="skin"></div>
        <div class="skin"></div>
        <div class="skin"></div>
        <div class="skin"></div>
        <div class="skin"></div>
	</div>	
	<button id="skinButton">Select</button>
<button id="closeSkin">Cancel</button>

</div>	
<!-- END SKIN BOX !!!!!!!!! -->


<!-- HOME NAME FORM !!!!!!!!! -->
<!-- HOME NAME FORM !!!!!!!!! -->	
<!-- HOME NAME FORM !!!!!!!!! -->		
<div class="center-box">	
	<form id="nameForm">
	<div id="logoImg">	
	<img id="topImage" src="hexicon.png" alt="Hex3" class="no-select">
	</div>	
	<!--<label for="playerName">Introduce tu nombre:</label> -->
	<input type="text" id="playerName" name="playerName" required placeholder="Player name" minlength="1" maxlength="20" pattern=".{1,20}">	
	<div id="cameraOptions">
	<label class="radio-button">
	<input type="radio" name="camera" value="1" checked>
	<span class="radio-custom"></span>
	<span class="radio-label">Cam 1</span>
	</label>
	<label class="radio-button">
	<input type="radio" name="camera" value="2">
	<span class="radio-custom"></span>
	<span class="radio-label">Cam 2</span>
	</label>
	</div>
	<button type="button" id="submitButton">PLAY</button>
	<div id="errorMessage" style="display: none; color: red;">The player's name must be between 1 and 20 characters.</div>	
	<div id="customizePlayerDiv">
	<button type="button" id="customPlayer">CUSTOMIZE SKIN</button>
	</div>	
	</form>
</div>
<!-- END HOME NAME FORM !!!!!!!!! -->		
	

<!-- CONTAINER END !!!!!!!!! -->
</div>
	

<!-- SVG GAME ELEMENT (CAMERA, PLAYER, etc !!!!!!!!! -->
<!-- SVG GAME ELEMENT (CAMERA, PLAYER, etc !!!!!!!!! -->
<!-- SVG GAME ELEMENT (CAMERA, PLAYER, etc !!!!!!!!! -->
<canvas id="gameCanvas" height="0" style="background-color: #ff0000;"> </canvas>
<svg id="firstP" xmlns="http://www.w3.org/2000/svg">  
	<g id="camera">
	<g id="hexagonGroup"></g> 
	</g>





	<g id="playerGroup" >
      
<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200" preserveAspectRatio="xMidYMid meet"><clipPath id="clipCircle"><circle cx="100" cy="100" r="100"/></clipPath><circle cx="50%" cy="50%" r="50%" fill="transparent" clip-path="url(#clipCircle)"></circle><circle cx="100" cy="100" r="100" fill="#ffff00" clip-path="url(#clipCircle)"></circle><polyline points="46.85714340209961,291.8095397949219" stroke="#ffff00" stroke-width="2" fill="none" clip-path="url(#clipCircle)"></polyline><polyline points="46,283" stroke="#ffff00" stroke-width="2" fill="none" clip-path="url(#clipCircle)"></polyline><line x1="41.904762268066406" y1="175.61904907226562" x2="144" y2="26.85714340209961" stroke="#00ff00" stroke-width="17" clip-path="url(#clipCircle)"></line></svg> 


	</g>			







	<text id="textLine1" x="20" y="40" fill="red"></text>
	<text id="textLine2" x="20" y="60" fill="blue"></text>
	<text id="textLine3" x="20" y="80" fill="green"></text>
	<text id="textLine4" x="20" y="100" fill="orange"></text>
	<text id="textLine5" x="20" y="120" fill="purple"></text>
	<text id="textLine6" x="95%" y="40" fill="red" text-anchor="end" font-weight="bold" >Points: 1018</text>
	<text id="textLine7" x="95%" y="60" fill="blue" text-anchor="end" font-weight="bold" > </text>
</svg>	
<!-- END SVG GAME ELEMENT (CAMERA, PLAYER, etc !!!!!!!!! -->

	
<circle id="bluePoint" cx="170" cy="170" r="8" fill="blue" />

<script src="/socket.io/socket.io.js"></script>
<script src="vertexFunciones.js"></script>


	
<!-- COMIENZA JUEGO LOGICA !!!!!!!!! -->
<!-- COMIENZA JUEGO LOGICA !!!!!!!!! -->
<!-- COMIENZA JUEGO LOGICA !!!!!!!!! -->	
<script>  
	  
document.addEventListener('DOMContentLoaded', function () {

let skinCode = 'sss';

	
const skins = document.querySelectorAll('.skin');
            const playerGroup = document.getElementById('playerGroup');
            const skinButton = document.getElementById('skinButton');

const closeSkinButton = document.getElementById('closeSkin');





            function generateRandomSVG() {
    const svgNamespace = "http://www.w3.org/2000/svg";
    const radius = 100;  // Adjusted for larger viewBox
    const colors = ["#FF5733", "#33FF57", "#3357FF", "#FF33A8", "#A833FF", "#FFD700", "#40E0D0"];
    const patterns = ["stripes", "dots", "grid", "waves"];

    // Create SVG element
    const svg = document.createElementNS(svgNamespace, "svg");
    svg.setAttribute("width", "50");
    svg.setAttribute("height", "50");
    svg.setAttribute("viewBox", "0 0 200 200");
    svg.setAttribute("preserveAspectRatio", "xMidYMid meet");

    // Define clip path for the circle
    const defs = document.createElementNS(svgNamespace, "defs");
    const clipPath = document.createElementNS(svgNamespace, "clipPath");
    clipPath.setAttribute("id", "clipCircle");
    const clipCircle = document.createElementNS(svgNamespace, "circle");
    clipCircle.setAttribute("cx", 100);
    clipCircle.setAttribute("cy", 100);
    clipCircle.setAttribute("r", 100);
    clipPath.appendChild(clipCircle);
    defs.appendChild(clipPath);
    svg.appendChild(defs);

    // Create the main circle and apply clip path
    const mainCircle = document.createElementNS(svgNamespace, "circle");
    mainCircle.setAttribute("cx", 100);
    mainCircle.setAttribute("cy", 100);
    mainCircle.setAttribute("r", radius);
    mainCircle.setAttribute("fill", colors[Math.floor(Math.random() * colors.length)]);
    mainCircle.setAttribute("clip-path", "url(#clipCircle)");
    svg.appendChild(mainCircle);

    // Add random pattern inside the circle
    const patternType = patterns[Math.floor(Math.random() * patterns.length)];
    switch (patternType) {
        case "stripes":
            addStripes(svg, colors);
            break;
        case "dots":
            addDots(svg, colors);
            break;
        case "grid":
            addGrid(svg, colors);
            break;
        case "waves":
            addWaves(svg, colors);
            break;
    }

    return svg;
}

function addStripes(svg, colors) {
    const svgNamespace = "http://www.w3.org/2000/svg";
    for (let i = 0; i < 10; i++) {
        const line = document.createElementNS(svgNamespace, "line");
        line.setAttribute("x1", 0);
        line.setAttribute("y1", i * 20);
        line.setAttribute("x2", 200);
        line.setAttribute("y2", i * 20);
        line.setAttribute("stroke", colors[Math.floor(Math.random() * colors.length)]);
        line.setAttribute("stroke-width", 5);
        line.setAttribute("clip-path", "url(#clipCircle)");
        svg.appendChild(line);
    }
}

function addDots(svg, colors) {
    const svgNamespace = "http://www.w3.org/2000/svg";
    for (let i = 0; i < 50; i++) {
        const dot = document.createElementNS(svgNamespace, "circle");
        dot.setAttribute("cx", Math.random() * 200);
        dot.setAttribute("cy", Math.random() * 200);
        dot.setAttribute("r", 5);
        dot.setAttribute("fill", colors[Math.floor(Math.random() * colors.length)]);
        dot.setAttribute("clip-path", "url(#clipCircle)");
        svg.appendChild(dot);
    }
}

function addGrid(svg, colors) {
    const svgNamespace = "http://www.w3.org/2000/svg";
    for (let i = 0; i < 10; i++) {
        const line1 = document.createElementNS(svgNamespace, "line");
        line1.setAttribute("x1", i * 20);
        line1.setAttribute("y1", 0);
        line1.setAttribute("x2", i * 20);
        line1.setAttribute("y2", 200);
        line1.setAttribute("stroke", colors[Math.floor(Math.random() * colors.length)]);
        line1.setAttribute("stroke-width", 2);
        line1.setAttribute("clip-path", "url(#clipCircle)");
        svg.appendChild(line1);

        const line2 = document.createElementNS(svgNamespace, "line");
        line2.setAttribute("x1", 0);
        line2.setAttribute("y1", i * 20);
        line2.setAttribute("x2", 200);
        line2.setAttribute("y2", i * 20);
        line2.setAttribute("stroke", colors[Math.floor(Math.random() * colors.length)]);
        line2.setAttribute("stroke-width", 2);
        line2.setAttribute("clip-path", "url(#clipCircle)");
        svg.appendChild(line2);
    }
}

function addWaves(svg, colors) {
    const svgNamespace = "http://www.w3.org/2000/svg";
    const wavePath = document.createElementNS(svgNamespace, "path");
    wavePath.setAttribute("d", "M0 100 Q 50 0, 100 100 T 200 100");
    wavePath.setAttribute("stroke", colors[Math.floor(Math.random() * colors.length)]);
    wavePath.setAttribute("stroke-width", 5);
    wavePath.setAttribute("fill", "none");
    wavePath.setAttribute("clip-path", "url(#clipCircle)");
    svg.appendChild(wavePath);
}




            // Generate random SVGs for each skin
            skins.forEach(skin => {
                const svg = generateRandomSVG();
                skin.appendChild(svg);
            });

            // Add click event listener for selection
            skins.forEach(skin => {
                skin.addEventListener('click', function() {
                    skins.forEach(s => s.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });

            // Add click event listener to the select button
            skinButton.addEventListener('click', function() {
    const selectedSkin = document.querySelector('.skin.selected');
    if (selectedSkin) {
        const svg = selectedSkin.querySelector('svg').cloneNode(true);
        svg.setAttribute('width', '20');
        svg.setAttribute('height', '20');
        playerGroup.innerHTML = '';
        playerGroup.appendChild(svg);

        // Print the SVG code to the console
        console.log(svg.outerHTML);

skinCode = svg.outerHTML;

        // Hide the selectSkin element
        selectSkin.style.display = 'none';
    }
});


// Add click event listener to the cancel button
            closeSkinButton.addEventListener('click', function() {
                // Hide the selectSkin div
                selectSkin.style.display = 'none';
            });




const nameForm = document.getElementById('nameForm');
const gameCanvas = document.getElementById('gameCanvas');
const canvas = document.getElementById('gameCanvas');
const modal = document.getElementById('gameOverModal');
const context = canvas.getContext('2d');
let NameSecure = '';
	
///CAM OPTIONS
let Camara = 1;
document.getElementById('cameraOptions').addEventListener('change', function(event) {
const selectedValue = event.target.value;
if (selectedValue === '1') { Camara = 1;
} else if (selectedValue === '2') { Camara = 2; }
console.log('Camara:', Camara);
});	


	
	
// DESPUES DE INTRODUCIR EL NOMBRE !!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!//////////
document.getElementById('submitButton').addEventListener('click', function () {
var playerNameInput = document.getElementById("playerName");
var errorMessage = document.getElementById("errorMessage");
if (playerNameInput.checkValidity()) {
// El formulario es válido, iniciar el juego
socket.on('connect_error', (error) => {
console.error('Error de conexión:', error); });
const playerName = document.getElementById('playerName').value;
console.log(`CLIENT EJEC. Name: ${playerName}`);
NameSecure = playerName;
//Ocultar el formulario y mostrar el canvas
nameForm.style.display = 'none';
gameCanvas.style.display = 'block';
hexagonGroup.style.display = 'block';
firstP.style.display = 'block';
// ACTIVAR EL SERVIDOR
socket.emit('playerNameEntered', playerName, skinCode);
} else {
// Mostrar mensaje de error
errorMessage.style.display = "block";
}		
});

	

//CUSTOM PLAYER BUTTON
document.getElementById('customPlayer').addEventListener('click', function () {
document.getElementById('paintBox').style.display = 'block'; // Para mostrar el retryBox
});

function preventZoom(event) {
event.preventDefault();
}

const socket = io();

//GREEN BALLS GENERATE AND DELETE
//GREEN BALLS GENERATE AND DELETE
//GREEN BALLS GENERATE AND DELETE
socket.on('greenCirclesGenerated', (circles) => {
	console.log('GREEN CIRCLES GENERATED.');
	greenCircles = [];
	greenCircles2 = [];
	//console.log('CIRLES PUSH:', circles);
	greenCircles.push(...circles);
	//console.log(`GreenCircles LENGTH: ${greenCircles.length}:`);
	generateGreenCircles();
});
socket.on('borrarGreen', () => {
	console.log('BORRAR GREEN CIRCLES.');
	const greenCircles = document.querySelectorAll('circle[fill="green"]');
	// Iterar sobre cada círculo verde y eliminarlo
	greenCircles.forEach(circle => {
	circle.remove();
	});
	const blueCircles = document.querySelectorAll('circle[fill="blue"]');
	// Iterar sobre cada círculo verde y eliminarlo
	blueCircles.forEach(circle => {
	circle.remove();
	});		
});
//END GREEN BALLS GENERATE AND DELETE
	

////FUNCION TEXT DE PUNTO
function pointText(x, y) {
const pointText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
pointText.setAttribute('x', x);
pointText.setAttribute('y', y); // Ajusta la posición del texto según sea necesario
pointText.setAttribute('text-anchor', 'middle');
pointText.setAttribute('fill', 'green');
pointText.setAttribute('font-size', '14px');
pointText.textContent = "+1 point";
hexagonGroup.appendChild(pointText);
// Después de 1 segundo, eliminar el texto
setTimeout(() => {
hexagonGroup.removeChild(pointText);
}, 500);
}

////FUNCION TEXT DE PUNTO
function speedText(x, y) {
const speedText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
speedText.setAttribute('x', x);
speedText.setAttribute('y', y); // Ajusta la posición del texto según sea necesario
speedText.setAttribute('text-anchor', 'middle');
speedText.setAttribute('fill', 'blue');
speedText.setAttribute('font-size', '14px');
speedText.textContent = "+ speed";
hexagonGroup.appendChild(speedText);
// Después de 1 segundo, eliminar el texto
setTimeout(() => {
hexagonGroup.removeChild(speedText);
}, 500);
}

////FUNCION JUGADOR TEXTO ELIMINATED
function playerText(x, y, name) {
const playerText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
playerText.setAttribute('x', x);
playerText.setAttribute('y', y); // Ajusta la posición del texto según sea necesario
playerText.setAttribute('text-anchor', 'middle');
playerText.setAttribute('fill', 'red');
playerText.setAttribute('font-size', '16px');
playerText.textContent =  name + " eliminated!";
hexagonGroup.appendChild(playerText);
// Después de 1 segundo, eliminar el texto
setTimeout(() => {
hexagonGroup.removeChild(playerText);
}, 500);
}		

//MANDAR COLISION A TODOS ELIMINAR CIRCULO VERDE !!!!!!!!!!!!!!!!!!
////////////////////////////////////////////////////////////	

socket.on('greenCircleCollision', (collisionIndex, indexToRemove, comproid) => {
if (comproid !== socket.id) {
//console.log(`BORRADOR ACTIVADO!!!`);	
const circleToRemoveC = document.getElementById('greenCircle_'+collisionIndex);
const circleToRemoveCB = document.getElementById('blueCircle_'+collisionIndex);
	
if (circleToRemoveC) {	
circleToRemoveC.parentNode.removeChild(circleToRemoveC);
let indice = greenCircles.findIndex(function(elemento) {
return elemento.z === collisionIndex;
});
if (indice !== -1) {
//console.log("Elemento eliminado correctamente", greenCircles[indice]);
greenCircles.splice(indice, 1);
// Mostrar el texto "+1 point" encima del círculo verde eliminado
pointText(circleToRemoveC.getAttribute('cx'), circleToRemoveC.getAttribute('cy') - 20);
} else {
//console.log("No se encontró ningún elemento con z igual a 10");
}	
}	

///BLUE VELOCIDAD CIRCLE:
if (circleToRemoveCB) {	
circleToRemoveCB.parentNode.removeChild(circleToRemoveCB);
let indice = greenCircles.findIndex(function(elemento) {
return elemento.z === collisionIndex;
});
if (indice !== -1) {
//console.log("Elemento eliminado correctamente", greenCircles[indice]);
greenCircles.splice(indice, 1);
// Mostrar el texto "+1 point" encima del círculo verde eliminado
speedText(circleToRemoveCB.getAttribute('cx'), circleToRemoveCB.getAttribute('cy') - 20);
} else {
//console.log("No se encontró ningún elemento con z igual a 10");
}	
}		
	
}
	
});	

//DETECTAR COLISION CON CIRCULOS VERDES !!!!!!!!!!!!!!!!!!
////////////////////////////////////////////////////////////


let segundosRestantes = 5;


let intervalo;

function detectarColisionesRectangulares(blueX, blueY, blueRadius, greenCircles) {
for (const circle of greenCircles) {	
const greenX = circle.x; 
const greenY = circle.y;
const greenRadius = 9;
const greenIndex = circle.z;	
// Calcular las coordenadas de los rectángulos delimitadores
const blueBoundingBox = {
x1: blueX - blueRadius, y1: blueY - blueRadius,
x2: blueX + blueRadius, y2: blueY + blueRadius };
const greenBoundingBox = {
x1: greenX - greenRadius, y1: greenY - greenRadius,
x2: greenX + greenRadius, y2: greenY + greenRadius };
// Verificar la colisión entre los rectángulos delimitadores
if (blueBoundingBox.x1 < greenBoundingBox.x2 && blueBoundingBox.x2 > greenBoundingBox.x1 &&
blueBoundingBox.y1 < greenBoundingBox.y2 && blueBoundingBox.y2 > greenBoundingBox.y1) {
const circleToRemoveC = document.getElementById('greenCircle_'+greenIndex);
//console.log(`COLISION Z: ${greenIndex}:`);			
//console.log(`REMOVE !!!!!!`, circleToRemoveC);
const circleToRemoveCB = document.getElementById('blueCircle_'+greenIndex);
	
if (circleToRemoveC) {	
circleToRemoveC.parentNode.removeChild(circleToRemoveC);
var indice = greenCircles.findIndex(function(elemento) {
    return elemento.z === circle.z;
});
if (indice !== -1) {
//console.log("Elemento eliminado correctamente", greenCircles[indice]);
greenCircles.splice(indice, 1);
socket.emit('greenCircleEaten');
socket.emit('collisionWithGreenCircle2', circle.z, indice, socket.id);
pointText(circleToRemoveC.getAttribute('cx'), circleToRemoveC.getAttribute('cy') - 20);
} else {
//console.log("No se encontró ningún elemento con z igual a 10");
}	
}

//BLUE CIRCLE VELOCIDAD COLISION
if (circleToRemoveCB) {	
//speedPlayer = 50;

function activarVelocidad() {
	            clearInterval(intervalo);

    Velocidad = true;
    const newVel = { velocidad: Velocidad };
    socket.emit('updateVelocidadServer', newVel);
    console.log('Velocidad activada');
    textLine7.textContent = `X2 SPEED`;

    segundosRestantes = 5;
    intervalo = setInterval(function() {
        segundosRestantes--;
        if (segundosRestantes > 0) {
            textLine7.textContent = `X2 SPEED - ${segundosRestantes} s`;
        } else {
            clearInterval(intervalo);
            Velocidad = false;
            console.log('Velocidad desactivada');
            const newVel = { velocidad: Velocidad };
            socket.emit('updateVelocidadServer', newVel);
            textLine7.textContent = ``;
        }
    }, 1000); // Actualizar cada segundo
}

// Llamar a la función para activar la velocidad
activarVelocidad();


	
 
circleToRemoveCB.parentNode.removeChild(circleToRemoveCB);
var indice = greenCircles.findIndex(function(elemento) {
return elemento.z === circle.z;
});
if (indice !== -1) {
//console.log("Elemento eliminado correctamente", greenCircles[indice]);
greenCircles.splice(indice, 1);
//socket.emit('greenCircleEaten');
socket.emit('collisionWithGreenCircle2', circle.z, indice, socket.id);
speedText(circleToRemoveCB.getAttribute('cx'), circleToRemoveCB.getAttribute('cy') - 20);
} else {
//console.log("No se encontró ningún elemento con z igual a 10");
}	
}
//END BLUE CIRCLE VELOCIDAD COLISION
	
// Colisión detectada
return true;
}
}
//console.log(`NO COLISION`);
// No hay colisión
return false;
}
	
createHexagons(socket, function() {
console.log("createHexagons end");
socket.emit('dibujarVerdes', 'numero');
});	
console.log('Camara:', Camara);	
	
//VARIABLES/////////////////////////////////////////////
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!/////	
let randomX = 0;	
let randomY = 0;	
let inicialX = 0;
let inicialY = 0;
let connectedUsers = 0;
let isMoving = false
const players = {}; // Objeto para almacenar la información de los jugadores
const hexagonGroup = document.getElementById('hexagonGroup');
const firstP = document.getElementById('firstP');
const bluePoint = {id: socket.id, name: '', x: 170,  y: 170,  color: 'blue', };
let topplayers = [];
const svgWidth = document.documentElement.clientWidth;
const svgHeight = document.documentElement.clientHeight;
let initialCameraX = svgWidth / 2 ;
let initialCameraY = svgHeight / 2 ;
let currentCameraX3 = 0;
let currentCameraY3 = 0;
let currentCamera10 = 0;
let currentCameraY10 = 0;
const camera = document.getElementById('camera');
//let playerElement = document.getElementById('playerGroup');
	
let currentCameraX4 = 0;	
let currentCameraY4 = 0;	
let textLine1 = document.getElementById('textLine1');
let textLine2 = document.getElementById('textLine2');
let textLine3 = document.getElementById('textLine3');
let textLine4 = document.getElementById('textLine4');
let textLine5 = document.getElementById('textLine5');
let textLine6 = document.getElementById('textLine6');
let textLine7 = document.getElementById('textLine7');
	
textLine1.classList.add('no-select');
textLine2.classList.add('no-select');
textLine3.classList.add('no-select');
textLine4.classList.add('no-select');
textLine5.classList.add('no-select');
textLine6.classList.add('no-select');
textLine7.classList.add('no-select');


let playerHeight = 25;
let playerWidth = 25;	

	
	
let CalculoCam = 0;
	
	
function addPlayer(nombre, puntos, color) {
const nuevoJugador = {
nombre: nombre,
puntos: puntos,
color: color
};
topplayers.push(nuevoJugador);
}

//CIRCULO AZUL DEFINIDO
const bluePointElement = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
bluePointElement.setAttribute('id', bluePoint.id);
bluePointElement.setAttribute('r', '8');
bluePointElement.setAttribute('fill', bluePoint.color);
bluePointElement.setAttribute('cx', bluePoint.x);
bluePointElement.setAttribute('cy', bluePoint.y);

let bX = 0;
let bY = 0;

/////////////////////////////////////////////////////////////////////

//CLICK LISTENER HEAGONGROUP!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
firstP.addEventListener('click', function (event) {
//console.log('HEXAGON GROUP LOG');
const mouseX = event.clientX - firstP.getBoundingClientRect().left;
const mouseY = event.clientY - firstP.getBoundingClientRect().top;
moveBluePoint(mouseX, mouseY);
});

//CONNECTED USERS////////////////////////////////
///////////////////////////////////////////////// 
//SOCKET.ON SIGNIFICA QUE ESTA ESCUCHANDO AL SERVIDOR. Son datos que vienen del servidor.
socket.on('userCount', function (count) {
connectedUsers = count;
drawUserCount(); // Llamar a la función para actualizar el texto en el canvas
});
function drawUserCount() {
context.fillStyle = 'black';
context.font = '16px Arial';
context.fillText(`Usuarios conectados: ${connectedUsers}`, 10, 5);
}	

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////	
//IN ORDER FUNCIONTS OF GAME
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//IN ORDER FUNCIONTS OF GAME
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

//5. ASIGN COLOR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
socket.on('assignColor', function (playerName) {
console.log('SOCKET ASSIGN COLOR');
socket.emit('updatePlayersRequest');
//X e Y random for Player al principio	
});	
	
	
//6. UPDATE TOP PLAYERS 2 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////	
let camProb = false;
socket.on('updatePlayers2', function (updatedPlayers2) {
console.log('SOCKET UPDATE PLAYERS 2');
topplayers = [];
//Iterar sobre el objeto de jugadores y actualizar la información
for (const playerId in updatedPlayers2) {
const player = updatedPlayers2[playerId];
//LOGS		
//console.log(`PLAYER2: ${playerId}, ${player.x}, ${player.y}, ${player.nombre},${player.color},${player.puntos}`);
addPlayer(player.nombre, player.puntos, player.color);

if(NameSecure === player.nombre){
textLine6.textContent = `Points: ${player.puntos}`;
textLine6.style.fill = player.color;
initialCameraX = svgWidth / 2 - player.x;
initialCameraY = svgHeight / 2 - player.y  ;
//console.log('Coord circ:', initialCameraX, initialCameraY);  
//bluePointElement.setAttribute('cx', player.x);
//bluePointElement.setAttribute('cy', player.y);
bX = player.x;
bY = player.y;
//CalculoCam = initialCameraY;	

//CAMERA MOVEMENT
if (camProb === false) {
camera.setAttribute('transform', `translate(${initialCameraX}, ${initialCameraY})`);
//playerElement.setAttribute('transform', `translate(${initialCameraX}, ${initialCameraY})`);
	
}

if (Camara===2){
camProb = true;
}
// END CAMERA MOVEMENT

inicialX = player.x;
inicialY = player.y;
findAndMarkClosestVertices(inicialX, inicialY,currentCameraX3,currentCameraY3);
}
	
}

const topPlayers = getTopPlayers();
textLine1.textContent = topPlayers.length >= 1 ? `#1 ${topPlayers[0].nombre}: ${topPlayers[0].puntos}` : '';
if (topPlayers[0] && topPlayers[0].color) { textLine1.style.fill = topPlayers[0].color; } else {}



	
textLine2.textContent = topPlayers.length >= 2 ? `#2 ${topPlayers[1].nombre}: ${topPlayers[1].puntos}` : '';
if (topPlayers[1] && topPlayers[1].color) {textLine2.style.fill = topPlayers[1].color; } else {}
textLine3.textContent = topPlayers.length >= 3 ? `#3 ${topPlayers[2].nombre}: ${topPlayers[2].puntos}` : '';
if (topPlayers[2] && topPlayers[2].color) {textLine3.style.fill = topPlayers[2].color; } else {}
textLine4.textContent = topPlayers.length >= 4 ? `#4 ${topPlayers[3].nombre}: ${topPlayers[3].puntos}` : '';
if (topPlayers[3] && topPlayers[3].color) {textLine4.style.fill = topPlayers[3].color; } else {}
textLine5.textContent = topPlayers.length >= 5 ? `#5 ${topPlayers[4].nombre}: ${topPlayers[4].puntos}` : '';
if (topPlayers[4] && topPlayers[4].color) {textLine5.style.fill = topPlayers[4].color; } else {}

});	

//7. GET TOP PLAYERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////	
function getTopPlayers() {
const sortedPlayers = topplayers.sort((a, b) => b.puntos - a.puntos);
const topPlayersx = sortedPlayers.slice(0, 5);
topPlayersx.forEach(topplayer => { });
return topPlayersx;
}	



















//9. UPDATE PLAYERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////

socket.on('updatePlayers', function (updatedPlayers) {
console.log('SOCKET UPDATE PLAYERS');
//Iterar sobre el objeto de jugadores y actualizar la información
for (const playerId in updatedPlayers) {
const player = updatedPlayers[playerId];

//PLAYER ELEMENT 
const existingPlayerElement = document.getElementById(playerId);


if (existingPlayerElement) {	


	
//existingPlayerElement.setAttribute('x', player.x);
//existingPlayerElement.setAttribute('y', player.y);
//const radius = parseFloat(existingPlayerElement.getAttribute('r')); // Convertir a número
const ptsf = parseFloat(player.puntos); 
const sizeCalc = (0.2 * ptsf) + 9;
//existingPlayerElement.setAttribute('r', sizeCalc);

//

let velocidadD = player.velocidad;

if (velocidadD===false){
existingPlayerElement.setAttribute('stroke', 'white'); // Color del borde
existingPlayerElement.setAttribute('stroke-width', '1'); // Ancho del borde
//existingPlayerElement.setAttribute('stroke-opacity', '0.5'); // Opacidad del borde
}
if (velocidadD===true){
existingPlayerElement.setAttribute('stroke', 'blue'); // Color del borde
existingPlayerElement.setAttribute('stroke-width', '3'); // Ancho del borde
//existingPlayerElement.setAttribute('stroke-opacity', '0.5'); // Opacidad del borde
}


} else {		


	
/*const playerElement = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
const ptsf = parseFloat(player.puntos); 
const sizeCalc = (0.2 * ptsf) + 9;	
playerElement.setAttribute('id', playerId);
playerElement.setAttribute('r', sizeCalc);
playerElement.setAttribute('fill', player.color);

//BORDE DEL CIRCULO	
playerElement.setAttribute('stroke', 'white'); // Color del borde
playerElement.setAttribute('stroke-width', '1'); // Ancho del borde
playerElement.setAttribute('stroke-opacity', '0.5'); // Opacidad del borde
	
playerElement.setAttribute('cx', player.x);
playerElement.setAttribute('cy', player.y);*/
	/////////////






   // const playerElement = document.getElementById('playerGroup');







// Crear el elemento <g>
                    const playerElement = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    
const svgContainer = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svgContainer.innerHTML = player.skinCode;
                    playerElement.appendChild(svgContainer);


const svgElement = playerElement.querySelector('svg');

                        // Obtener y mostrar los atributos width y height
                        const width = svgElement.getAttribute('width');
                        const height = svgElement.getAttribute('height');








console.log("CompJugador:", playerElement, playerId, player);


//	let svgElement = document.querySelector('#playerGroup svg');

//let width = svgElement.getAttribute('width');
//let height = svgElement.getAttribute('height');

console.log("Width:", width);
console.log("Height:", height);

				   
	

//const playerElement = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
//playerElement.setAttribute('width', playerWidth);
//playerElement.setAttribute('height', playerHeight);
playerElement.setAttribute('id', playerId);

//playerElement.setAttribute('x', player.x - (playerWidth/2));
//playerElement.setAttribute('y', player.y - (playerHeight/2));
//playerElement.setAttribute('r', 14); // Radio del círculo
//playerElement.setAttribute('fill', 'yellow');	

//playerElement.setAttribute('fill', 'url(#image)'); // Aplicar el patrón de imagen como relleno
	

playerElement.setAttribute('data-x', player.x);
playerElement.setAttribute('data-y', player.y );		


console.log('xy: ', player.x, player.y  );
	

const currentX = Number(playerElement.getAttribute('data-x'));
const currentY = Number(playerElement.getAttribute('data-y'));

console.log('cxy: ', currentX, currentY  );
	

// Nuevas coordenadas a las que se moverá el grupo
const newX = player.x;
const newY = player.y;

// Calcula la diferencia entre las coordenadas actuales y las nuevas
const deltaX = player.x - (width/2);
const deltaY = player.y  - (height/2);

	console.log('dxy: ', width, deltaY  );



playerElement.setAttribute('transform', `translate(${deltaX},${deltaY})`);



if(playerId !== socket.id) {
// Agregar atributo de jugador al círculo
playerElement.setAttribute('data-player-id', 'jugador'); 
}


hexagonGroup.appendChild(playerElement);

	
}

//TEXT ELEMENT
const existingTextElement = document.getElementById(playerId + '-name');
if (existingTextElement) {
existingTextElement.setAttribute('x', player.x);
existingTextElement.setAttribute('y', player.y - 8);
existingTextElement.textContent = player.nombre + ' ('+ player.puntos + ')';
} else {
const textElement2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
textElement2.setAttribute('id', playerId + '-name');
textElement2.setAttribute('x', player.x);
textElement2.setAttribute('y', player.y - 10);
textElement2.setAttribute('text-anchor', 'middle');
textElement2.setAttribute('fill', 'green');
textElement2.setAttribute('font-size', '16px');
textElement2.textContent = player.nombre + ' ('+ player.puntos + ')';
textElement2.classList.add('no-select');
hexagonGroup.appendChild(textElement2);
}
}
});

//WHEN MOVE FUNCTIONS```````````````````````````````````````````````````-------------------------------------------------
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!-------------------------------------------------
//WHEN MOVE FUNCTIONS```````````````````````````````````````````````````-------------------------------------------------
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!-------------------------------------------------

//1. MOVE BLUE POINT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////////
	
function moveBluePoint( clickX, clickY ) {
//const circles = document.querySelectorAll('circle[data-player-id="jugador"]');
//circles.forEach((circle, index) => {
//   console.log(`!!!!!!!!!!!Círculo ${index + 1}:`);
//   console.log(circle); // Esto imprimirá toda la información del círculo en la consola
//});

//CAMARA/////////////////////
const transformAttribute = camera.getAttribute('transform');
const match = transformAttribute.match(/translate\(([^,]+),([^,]+)\)/);
if (match) {
currentCameraX4 = parseFloat(match[1]);
currentCameraY4 = parseFloat(match[2]);
//console.log('Coordenadas cámara:', currentCameraX4, currentCameraY4);  
} else { console.error('No cámara.'); }
//CAMARA END/////////////////////
	
if (!isMoving) { 
console.log('/////Move Player//////')
isMoving = true;  
drawUserCount();

const closestGreenVertex = findClosestGreenVertexToClick(clickX - currentCameraX4, clickY - currentCameraY4,currentCameraX3,currentCameraY3); 
//console.log('Vértice cercano: ', closestGreenVertex.x, closestGreenVertex.y); 
animateBluePoint(closestGreenVertex.x, closestGreenVertex.y);		
}
	
}	

    let Velocidad = false;
	

//3. ANIMATE BLUE POINT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
/////////////////////////////////////////////////////////////////////////////	
function animateBluePoint(destinationX, destinationY) {
//console.log('1. Animate Blue Point');
//const startX = parseFloat(bluePointElement.getAttribute('x'));
//const startY = parseFloat(bluePointElement.getAttribute('y'));
const startX = bX;
const startY = bY;
const startTime = performance.now();
const duration = 50; // 1 seg
function update() {
const currentTime = performance.now();
const elapsed = currentTime - startTime;
const progress = Math.min(elapsed / duration, 1);
const newX = startX + progress * (destinationX - startX);
const newY = startY + progress * (destinationY - startY);	
//bluePointElement.setAttribute('cx', newX);
//bluePointElement.setAttribute('cy', newY);
bX = newX;
bY = newY;	
if (progress < 1) { requestAnimationFrame(update);
} else {
// Animación completada, emitir datos al servidor
socket.emit('animationData', { start: { x: startX, y: startY }, end: { x: newX, y: newY } });
// Supongamos que newPosition es un objeto con las nuevas coordenadas
const newPosition = { x:  newX , y: newY, velocidad: Velocidad };
socket.emit('updatePosition', newPosition);
inicialX = newX; inicialY = newY;	
}
} requestAnimationFrame(update);
}		

//4. SOCKET ANIMATE BLUE POINT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
//let CalculoCam = 0;
let currentCameraX4p = 0;
let currentCameraY4p = 0;
let Resto;
let Resto2;
let Resto3;
let Resto4;
let Resto5;

socket.on('animateBluePoint', function (animationData) {
//console.log('SOCKET ANIMATE BLUE POINT');
const playerId = animationData.playerId;
const data = animationData.data;
const txt = animationData.playerName;
	const playerSpeed = animationData.playerSpeed;
	
//console.log('playerSpeed: ', playerSpeed  );

	
// Encuentra el círculo correspondiente al jugador
const playerElement = document.getElementById(playerId);
console.log('playerElement: ', playerElement  );

	
const textElement2 = document.getElementById(playerId + '-name');
const xCoordinate = playerElement.getAttribute('data-y');
//console.log('CordY1: ', xCoordinate  );

animateCircleLocally(playerElement, data.start, data.end, playerId, playerSpeed);
animateNameLocally(textElement2, data.start, data.end);

//FINISCHED ANIMATE CIRCLE LOCALLY !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	
animateCircleLocally(playerElement, data.start, data.end, playerId,playerSpeed, function() {

const xCoordinate = playerElement.getAttribute('data-y');
//console.log('CordY2: ', xCoordinate  );

//CAMARAS MOVIMIENTO !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!////////////////
//CAMARAS MOVIMIENTO !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!////////////////

if(Camara===2) {
//CAMARA/////////////////////
const transformAttribute = camera.getAttribute('transform');
const match = transformAttribute.match(/translate\(([^,]+),([^,]+)\)/);
if (match) {
currentCameraX4p = parseFloat(match[1]);
currentCameraY4p = parseFloat(match[2]);
} else {
console.error('No se pudieron obtener las coordenadas de la cámara.');
}
console.log('1. CAM Y: ', currentCameraY4p  );
//CAMARA END/////////////////////        

const currentX = bX; 
const currentY = bY; 
const bluePointRect = playerElement.getBoundingClientRect();
const bluePointWidth = bluePointRect.width;
const bluePointHeight = bluePointRect.height;

console.log('bluePointWidth!!!!!!:',   bluePointWidth );
	

//DERECHA!!!!!
const bluePointRightX = currentX + bluePointWidth;
const limitRightX = - currentCameraX4p + (window.innerWidth * 0.7);
if (bluePointRightX > limitRightX) {      
//if(MoveCam){
CalculoCam = CalculoCam + svgWidth / 3;
console.log('CalculoCam!!!!!!:',   limitRightX );
animateCam (10,  10  ,bX, bY, svgWidth,  function() {
//MoveCam = true;
});   
//}
}

///IZQUIERDA!!!!!!!
const bluePointRightX2 = currentX - bluePointWidth;
const limitRightX2 = - currentCameraX4p + (window.innerWidth * 0.3);
if (bluePointRightX2 < limitRightX2) {
//if(MoveCam){
CalculoCam = CalculoCam - svgWidth / 3;
console.log('CalculoCam !!!!!!:',   limitRightX2 );
animateCam2 (10,  10  ,bX, bY,svgWidth,  function() {
//MoveCam = true;
});   
//}
}

//ARRIBA!!!!!!! por modificar
console.log('2. bY: ',   bY ); 
const bluePointRightXA = currentY - bluePointHeight;
console.log('3. bluePointRightXA: ',  bluePointRightXA  );
const limitRightY = - currentCameraY4p + (window.innerHeight * 0.7);
if (bluePointRightXA > limitRightY) {      
//if(MoveCam){
CalculoCam = CalculoCam + svgHeight / 3;
//console.log('5. CalculoCam: ',   CalculoCam  );
animateCam3 (10,  10  , bX, bY, svgHeight,function() {
//MoveCam = true;
});   
//}
}
console.log('Limite tot. ', svgWidth   ); 
console.log('Limite der. ',  limitRightX  ); 
console.log('Limite izq. ',  limitRightX2  );
	
//ABAJO!!!!!!!!
const bluePointRightXA2 = currentY + bluePointHeight;
	
const limitRightY2 = - currentCameraY4p + (window.innerHeight * 0.3);
if (bluePointRightXA2 < limitRightY2) {      
//if(MoveCam){
//CalculoCam = CalculoCam + svgHeight / 3;
//console.log('5. CalculoCam: ',   CalculoCam  );
animateCam4 (10,  10  ,bX, bY, svgHeight, function() {
//MoveCam = true;
});   
//}
}

}
	
// END 30% MENOS CAMARA IZQUIERDA!!!!!!!

//console.log('La animación ha terminado');
findAndMarkClosestVertices(inicialX, inicialY,currentCameraX3,currentCameraY3);
isMoving = false;
});
});	

////ATRAS///////////
// ANIMATE CAM 2 CAMARA MOVIMIENTO !!!!!!!!!!!!
////////////////////

//5. ANIMATE CIRCLE LOCALLY !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
let speedPlayer = 500;			  
function animateCircleLocally(circleElement, start, end, playerId, playerSpeed, callback) {
//console.log('ANIMATE CIRCLE LOCALLY');
		let duration = 500;

if(playerSpeed === false){
	 duration = 500;

}
if(playerSpeed === true){
	 duration = 50;

}	
const startTime = performance.now();
function update() {
const currentTime = performance.now();
const progress = Math.min((currentTime - startTime) / duration, 1);
const newX = start.x + progress * (end.x - start.x);
const newY = start.y + progress * (end.y - start.y);	


	
	
//circleElement.setAttribute('x', newX - (playerWidth/2));
//circleElement.setAttribute('y', newY- (playerHeight/2));


    const svgElement = circleElement.querySelector('svg');

const width = svgElement.getAttribute('width');
        const height = svgElement.getAttribute('height');
        
        console.log("SVG Width:", width);
        console.log("SVG Height:", height);	
	

//	circleElement.setAttribute('data-x', newX );
//circleElement.setAttribute('data-y', newY);


circleElement.setAttribute('transform', `translate(${newX-(width/2)},${newY-(height/2)})`);
	
//const velocidad = players[playerId].velocidad; // Aquí obtienes la velocidad del jugador
//console.log(`VELOCIDAD!!!: ${playerSpeed}`);


//circleElement.setAttribute('cx', start.x);
//circleElement.setAttribute('cy', start.y);	
	
if (socket.id===playerId) {
	
////CAMERA MOVEMENT
const newXCam = svgWidth / 2 - newX;
const newYCam = svgHeight / 2 - newY;	
if(Camara===1)
{
camera.setAttribute('transform', `translate(${newXCam}, ${newYCam})`);
	//playerElement.setAttribute('transform', `translate(${newXCam}, ${newYCam})`);

//console.log(`CamY: ${newYCam}`);
//console.log(`bY: ${bY}`);    
}
////END CAMERA MOVEMENT

// Obtener el radio del círculo como una cadena de texto
const radiusAsString = circleElement.getAttribute('r');
// Convertir la cadena a un número flotante (float)
//const radius = parseFloat(radiusAsString);
const radius = 10;
	
detectarColisiones(circleElement);
detectarColisionesRectangulares(newX, newY, radius, greenCircles);
}	

if (progress < 1) { requestAnimationFrame(update); } 
else {
// La animación ha terminado
if (typeof callback === 'function') { callback(); } 	
}	
} requestAnimationFrame(update);
	
}

//6. ANIMATE TEXT NAME !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
function animateNameLocally(circleElement, start, end) {
//console.log('ANIMATE TEXT LOCALLY');
const duration = 100;
const startTime = performance.now();
function update() {
const currentTime = performance.now();
const progress = Math.min((currentTime - startTime) / duration, 1);
const newX = start.x + progress * (end.x - start.x);
const newY = start.y + progress * (end.y - start.y);
	
circleElement.setAttribute('x', newX);
circleElement.setAttribute('y', newY - 8);

if (progress < 1) {
requestAnimationFrame(update); } }
requestAnimationFrame(update);
	
}	

//8. DETECTAR COLISION !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////	
function detectarColisiones(playerElement) {		
document.querySelectorAll('circle[data-player-id]').forEach((otherCircle) => {
const playerIdN = otherCircle.getAttribute('id');
const blueRadius = parseFloat(playerElement.getAttribute('r')); 
const greenRadius = parseFloat(otherCircle.getAttribute('r'));
const blueX = parseFloat(playerElement.getAttribute('cx'));
const blueY = parseFloat(playerElement.getAttribute('cy'));	
const greenX = parseFloat(otherCircle.getAttribute('cx'));
const greenY = parseFloat(otherCircle.getAttribute('cy'));

// Calcular las coordenadas de los cuadros delimitadores

const blueBoundingBox = {
x1: blueX - blueRadius, y1: blueY - blueRadius,
x2: blueX + blueRadius, y2: blueY + blueRadius };

const greenBoundingBox = {
x1: greenX - greenRadius, y1: greenY - greenRadius,
x2: greenX + greenRadius, y2: greenY + greenRadius};
	
// Verificar la colisión entre los cuadros delimitadores
if (blueBoundingBox.x1 < greenBoundingBox.x2 &&
blueBoundingBox.x2 > greenBoundingBox.x1 &&
blueBoundingBox.y1 < greenBoundingBox.y2 &&
blueBoundingBox.y2 > greenBoundingBox.y1 ) {

if (blueRadius > greenRadius){ 
console.log(`ID Jugador: (${socket.id}), (${blueRadius})`);
console.log(`ID Enemigo: (${playerIdN}), (${greenRadius})`); 

//console.log(`Radio Jugador:`, blueRadius); 
//console.log(`Radio Enemigo:`, greenRadius); 
	
console.log(`HAS COMIDO AL OTRO JUGADOR`); 

socket.emit('eliminarJugador', playerIdN);
	
}else if (blueRadius < greenRadius){
console.log(`ID Jugador: (${socket.id}), (${blueRadius})`);
console.log(`ID Enemigo: (${playerIdN}), (${greenRadius})`); 

//console.log(`Radio Jugador:`, blueRadius); 
//console.log(`Radio Enemigo:`, greenRadius); 

socket.emit('eliminarJugador', socket.id);
	
console.log(`GAME OVER2!!`); 
}
}
});	
//console.log('La detección de colisiones ha terminado.');
}	

//ELIMINAR JUGADOR DE TODOS CLIENTES CUANDO COLISION !!!!!!!!!!!!!!!!!!
////////////////////////////////////////////////////////////		
socket.on('eliminarJugadorEnCliente', (playerIdN) => {

var circulo = document.getElementById(playerIdN);
var x = circulo.getAttribute('cx');
var y = circulo.getAttribute('cy');	
if (circulo) {
circulo.parentNode.removeChild(circulo);

	
} else {
console.log("El círculo con el ID especificado no fue encontrado.");
}

var nombre = document.getElementById(playerIdN + '-name');
var texto = nombre.textContent;

	
if (nombre) {
nombre.parentNode.removeChild(nombre);
console.log("ELIMINADO: ." + texto);

playerText(x, y, texto);
	
	
} else {
console.log("El nombre con el ID especificado no fue encontrado.");
}
	
if (playerIdN===socket.id){
var newPoints = textLine6.textContent;
var pointsParagraph = document.getElementById("points");
pointsParagraph.textContent =  newPoints;	
gameCanvas.style.display = 'none';
hexagonGroup.style.display = 'none';
camera.style.display = 'none';
document.getElementById("retryBox").style.visibility = "visible";
var retryButton = document.getElementById("retryButton");
retryButton.onclick = function() {
console.log("Retry Game.");
location.reload();
};	
}
	
console.log("ELIMINAR JUGADOR", playerIdN );
	
});	

/////////////////////////////////////////////////////////////
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
//END DOM	 
});
//END DOM
	
</script>

<script src="createHexagons.js">
console.log('SCRIPT INI 2');
</script>

<script src="greenCircles.js">
console.log('SCRIPT INI 3');
</script>	

<script src="cameraMov.js">
console.log('SCRIPT INI 5');
</script>

<script src="lienzoFunciones.js"></script>
	
</body>
</html>
