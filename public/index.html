<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
	  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
  <title>Not-Hex-A</title>
	
<style>	  
	
@keyframes circleAnimationWithDuration {
from { r: 5; }  to { r: 7; } }
	
#fixedText {
position: fixed;
top: 5vh;
right: 5vw;
z-index: 999;
background-color: red;
color: white;
padding: 10px;
border-radius: 5px;
font-size: 2vw;
max-width: 90%; }
	
body {
margin: 0;
display: flex;
background-color: #0000FF; }
	
form {
text-align: center; }
#svg-container {
width: 100vw;
height: 100vh;
overflow: auto;
touch-action: pinch-zoom; }
	
#gameCanvas {
top: 0;
left: 0;
width: 0;
position: absolute;
display: none; }
	
#hexagonGroup {
top: 0;
left: 0;
width: 100vw;
height: 100vh;	
position: absolute;
z-index: 1;
display: none; }
	
#firstP {
top: 0;
left: 0;
width: 100vw;
height: 100vh;
background-color: #000000;
position: absolute;
z-index: 1;
display: none; }
	
#bluePoint { display: none; }
  
</style>
</head>

<body>

<form id="nameForm">
    <label for="playerName">Introduce tu nombre:</label>
    <input type="text" id="playerName" name="playerName" required>
    <button type="button" id="submitButton">Aceptar</button>
	<div id="cameraOptions">
	<label> <input type="radio" name="camera" value="1"> Opción 1 </label>
	<label> <input type="radio" name="camera" value="2"> Opción 2 </label>
	</div>	
</form>

<canvas id="gameCanvas" height="0" style="background-color: #ff0000;"> </canvas>

<div id="svg-container" ondblclick="preventZoom(event)"> </div>

<div id="fixedText"> </div>

<svg id="firstP" xmlns="http://www.w3.org/2000/svg">  
<g id="camera">
<g id="hexagonGroup">
<text id="textLine1" x="10" y="20" fill="red">
  </text>
  <text id="textLine2" x="10" y="40" fill="blue">
  </text>
  <text id="textLine3" x="10" y="60" fill="green">
  </text>
  <text id="textLine4" x="10" y="80" fill="orange">
  </text>
  <text id="textLine5" x="10" y="100" fill="purple">
  </text>
</g> </g>
</svg>	
	
<circle id="bluePoint" cx="170" cy="170" r="8" fill="blue" />

<script src="/socket.io/socket.io.js"></script>
    	  
<script>  
// COMIENZA EL JUEGO !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// CLIENT /////////////////////////////////////////////////////
	  
document.addEventListener('DOMContentLoaded', function () {
	
const nameForm = document.getElementById('nameForm');
const gameCanvas = document.getElementById('gameCanvas');
const canvas = document.getElementById('gameCanvas');
const context = canvas.getContext('2d');
const socket = io();
let NameSecure = '';
	
///CAM OPTIONS
let Camara = null;
document.getElementById('cameraOptions').addEventListener('change', function(event) {
const selectedValue = event.target.value;
if (selectedValue === '1') { Camara = 1;
} else if (selectedValue === '2') { Camara = 2; }
console.log('Camara:', Camara);
});	

// DESPUES DE INTRODUCIR EL NOMBRE !!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!////
	
document.getElementById('submitButton').addEventListener('click', function () {
	socket.on('connect_error', (error) => {
    	console.error('Error de conexión:', error); });
	const playerName = document.getElementById('playerName').value;
	console.log(`CLIENT EJEC. Name: ${playerName}`);
	NameSecure = playerName;
	//Ocultar el formulario y mostrar el canvas
	nameForm.style.display = 'none';
	gameCanvas.style.display = 'block';
	hexagonGroup.style.display = 'block';
	firstP.style.display = 'block';
	// ACTIVAR EL SERVIDOR
	socket.emit('playerNameEntered', playerName);
});

function preventZoom(event) {
	event.preventDefault();
}

const hexagonMap = [
    [ { direction: 'NE' },  { direction: 'E' }, { direction: 'SE' }, { direction: 'E' }, { direction: 'SE' }, { direction: 'E' }, { direction: 'SE' }, { direction: 'E' } ],
    [ { direction: 'NW' },  { direction: 'ES' }, { direction: 'E' }, { direction: 'ES' }, { direction: 'E' }, { direction: 'ES' }, { direction: 'E' }, { direction: 'ES' }, { direction: 'E' } ],
    [ { direction: 'NW' },   { direction: 'ES' }, { direction: 'E' }, { direction: 'ES' }, { direction: 'E' }, { direction: 'ES' }, { direction: 'E' }, { direction: 'ES' }, { direction: 'E' } ],
    [ { direction: 'SW' },   { direction: 'ES' }, { direction: 'E' }, { direction: 'ES' }, { direction: 'E' }, { direction: 'ES' }, { direction: 'E' }, { direction: 'ES' }, { direction: 'E' } ],
    // Repite el patrón de filas según sea necesario para tener 20 filas en total
];

//CREATE HEXAGON PANAL
createHexagons();

console.log('Camara:', Camara);	
	
//VARIABLES/////////////////////////////////////////////
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
let randomX = 0;	
let randomY = 0;	
let inicialX = 0;
let inicialY = 0;
let connectedUsers = 0;
let isMoving = false
const players = {}; // Objeto para almacenar la información de los jugadores
const hexagonGroup = document.getElementById('hexagonGroup');
const firstP = document.getElementById('firstP');
const bluePoint = {id: socket.id, name: '', x: 170,  y: 170,  color: 'blue', };
let topplayers = [];
const svgWidth = document.documentElement.clientWidth;
const svgHeight = document.documentElement.clientHeight;
let initialCameraX = svgWidth / 2 ;
let initialCameraY = svgHeight / 2 ;
let currentCameraX3 = 0;
let currentCameraY3 = 0;
let currentCamera10 = 0;
let currentCameraY10 = 0;
const camera = document.getElementById('camera');
let currentCameraX4 = 0;	
let currentCameraY4 = 0;	
let JugadorDatos = [];
let radioJugador = 0;
let textLine1 = document.getElementById('textLine1');
let textLine2 = document.getElementById('textLine2');
let textLine3 = document.getElementById('textLine3');
let textLine4 = document.getElementById('textLine4');
let textLine5 = document.getElementById('textLine5');

function addPlayer(nombre, puntos, color) {
	const nuevoJugador = {
	nombre: nombre,
	puntos: puntos,
	color: color
	};
	topplayers.push(nuevoJugador);
}

//CIRCULO AZUL DEFINIDO
const bluePointElement = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    bluePointElement.setAttribute('id', bluePoint.id);
    bluePointElement.setAttribute('r', '8');
    bluePointElement.setAttribute('fill', bluePoint.color);
    bluePointElement.setAttribute('cx', bluePoint.x);
    bluePointElement.setAttribute('cy', bluePoint.y);

let bX = 0;
let bY = 0;

/////////////////////////////////////////////////////////////////////

//CLICK LISTENER HEAGONGROUP!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
firstP.addEventListener('click', function (event) {
	//console.log('HEXAGON GROUP LOG');
	const mouseX = event.clientX - firstP.getBoundingClientRect().left;
        const mouseY = event.clientY - firstP.getBoundingClientRect().top;
	
	moveBluePoint(mouseX, mouseY);
});

//CONNECTED USERS////////////////////////////////
///////////////////////////////////////////////// 
	
//SOCKET.ON SIGNIFICA QUE ESTA ESCUCHANDO AL SERVIDOR. Son datos que vienen del servidor.
  socket.on('userCount', function (count) {
    connectedUsers = count;
    drawUserCount(); // Llamar a la función para actualizar el texto en el canvas
  });
  function drawUserCount() {
    context.fillStyle = 'black';
    context.font = '16px Arial';
    context.fillText(`Usuarios conectados: ${connectedUsers}`, 10, 5);
  }	


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////	
//IN ORDER FUNCIONTS OF GAME
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//IN ORDER FUNCIONTS OF GAME
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
//1. CREATE HEXAGONS///////////////////////////!!!!!!!!
/////////////////////////////////////////////////!!!!!!

function createHexagons(callback) {
const hexagonGroup = document.getElementById('hexagonGroup');
const hexagonSize = 50;
const numRows = hexagonMap.length;
const numCols = hexagonMap[0].length;
const hexWidth = hexagonSize * Math.sqrt(3);
const hexHeight = hexagonSize * Math.sqrt(3);
let minX = Infinity; let maxX = -Infinity;
let minY = Infinity; let maxY = -Infinity;
for (let row = 0; row < numRows; row++) {
for (let col = 0; col < numCols; col++) {
const x = col * (hexWidth * 0.87);
const y = row * hexHeight + (col % 2 === 1 ? hexHeight / 2 : 0);
minX = Math.min(minX, x); maxX = Math.max(maxX, x);
minY = Math.min(minY, y); maxY = Math.max(maxY, y);
const hexagon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
hexagon.setAttribute('points', getHexagonPoints(x, y, hexagonSize));
hexagon.setAttribute('fill', 'none');
hexagon.setAttribute('stroke', 'gray');
hexagon.setAttribute('stroke-width', '2');
// Accede al mapa de hexágonos para obtener la dirección
const direction = hexagonMap[row][col].direction;
hexagon.addEventListener('click', function() {
console.log(`Hexágono en (${row}, ${col}) con dirección ${direction} clickeado.`);
});
hexagonGroup.appendChild(hexagon);
} }
const mapWidth = maxX - minX + hexWidth;
const mapHeight = maxY - minY + hexHeight;
console.log('Ancho total del mapa hexagonal:', mapWidth);
console.log('Altura total del mapa hexagonal:', mapHeight);
if (callback) {
callback(); }
}
createHexagons(function() {
console.log("createHexagons end");
//DRAW GREEN RANDOM CIRCLES WHEN FINISHED	
//drawGreenCirclesOnRandomPoints();	
});
	
//2. GET HEXAGON POINTS///////////////////////////!!!!!!
///////////////////////////////////////////////!!!!!!!!!
	
function getHexagonPoints(x, y, size) {
const points = [];
for (let i = 0; i < 6; i++) {
const angle = (2 * Math.PI / 6) * i;
const pointX = x + size * Math.cos(angle);
const pointY = y + size * Math.sin(angle);
const coordinate = `${pointX},${pointY}`;   
console.log(`Coordenada: (${coordinate})`); 
// Imprime la coordenada en consola
points.push(coordinate);
} return points.join(' ');
}

//3. DRAW GREEN CIRCLES RANDOM !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////

/*function drawGreenCirclesOnRandomPoints() {
const hexagons = document.querySelectorAll('#hexagonGroup polygon');
const svg = document.querySelector('svg');
const coordinates = [];
for (let i = 0; i < 6; i++) {
// Selecciona un hexágono al azar
const randomHexagon = hexagons[Math.floor(Math.random() * hexagons.length)];
const points = randomHexagon.getAttribute('points').split(' ');
// Selecciona dos puntos aleatorios que conformen una línea dentro del hexágono
const randomPointIndex1 = Math.floor(Math.random() * points.length);
const randomPointIndex2 = (randomPointIndex1 + 1) % points.length;
const [x1, y1] = points[randomPointIndex1].split(',').map(Number);
const [x2, y2] = points[randomPointIndex2].split(',').map(Number);
// Elije un punto aleatorio entre los dos puntos seleccionados
const randomT = Math.random();
const x = x1 + randomT * (x2 - x1);
const y = y1 + randomT * (y2 - y1);
coordinates.push({ x, y });
//console.log(`Green Circle: (${x}, ${y})`); 	
}
socket.emit('sendCoordinates', coordinates);
}	
*/
//4. CALCULATE HEXAGON VERTEX!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////	

const hexagonVertices = [];
function calculateHexagonVertices() {
const hexagons = document.querySelectorAll('#hexagonGroup polygon');
hexagons.forEach(hexagon => {
const points = hexagon.getAttribute('points').split(' ');
const vertices = [];
// Iterar sobre los vértices del hexágono
for (let i = 0; i < points.length; i++) {
const [x, y] = points[i].split(',').map(Number);
vertices.push({ x, y }); }
hexagonVertices.push(vertices); });
// Imprimir las coordenadas de los vértices en la consola
hexagonVertices.forEach((vertices, hexIndex) => {
//console.log(`Hexágono ${hexIndex + 1}:`);
vertices.forEach((vertex, index) => {
//console.log(`Vértice ${index + 1}: (${vertex.x}, ${vertex.y})`);
});});
}
calculateHexagonVertices();	
console.log("Longitud de hexagonVertices:", hexagonVertices.length);
function printRandomValue(min, max) {
	const randomValue = Math.floor(Math.random() * (max - min + 1)) + min;
	return randomValue;
}	
let randomC = printRandomValue(1,  hexagonVertices.length  );
let randomC6 = printRandomValue(0, 5 );
randomX = hexagonVertices[randomC][randomC6].x;
randomY = hexagonVertices[randomC][randomC6].y;
console.log("RandomHex:", randomC);
console.log("Elemento de hexagonVertices:", hexagonVertices[randomC][randomC6]);

//RANDOM X e Y for SERVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
function newRandomForServer() {
	const coordinatesR = [];
	coordinatesR.push({ x: randomX, y: randomY });
	console.log(`CoordsR: ${randomX},${randomY}`);
	socket.emit('sendCoordinatesR', coordinatesR);	
}	

//5. ASIGN COLOR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
socket.on('assignColor', function (playerName) {
console.log('SOCKET ASSIGN COLOR');
socket.emit('updatePlayersRequest');
//X e Y random for Player al principio	
newRandomForServer();
});	

//6. UPDATE TOP PLAYERS 2 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////	

socket.on('updatePlayers2', function (updatedPlayers2) {
console.log('SOCKET UPDATE PLAYERS 2');
topplayers = [];
//Iterar sobre el objeto de jugadores y actualizar la información
for (const playerId in updatedPlayers2) {
const player = updatedPlayers2[playerId];
//LOGS		
console.log(`PLAYER2: ${playerId}, ${player.x}, ${player.y}, ${player.nombre},${player.color},${player.puntos}`);
addPlayer(player.nombre, player.puntos, player.color);

if(NameSecure === player.nombre){
radioJugador = player.puntos;
initialCameraX = svgWidth / 2 - player.x;
initialCameraY = svgHeight / 2 - player.y  ;
//console.log('Coord circ:', initialCameraX, initialCameraY);  
//bluePointElement.setAttribute('cx', player.x);
//bluePointElement.setAttribute('cy', player.y);
bX = player.x;
bY = player.y;
camera.setAttribute('transform', `translate(${initialCameraX}, ${initialCameraY})`);
console.log('R. Numbers:', randomX, randomY);  
inicialX = player.x;
inicialY = player.y;
findAndMarkClosestVertices();
}
	
}

const topPlayers = getTopPlayers();
textLine1.textContent = topPlayers.length >= 1 ? `#1 ${topPlayers[0].nombre}: ${topPlayers[0].puntos}` : '';
if (topPlayers[0] && topPlayers[0].color) { textLine1.style.fill = topPlayers[0].color; } else {}
textLine2.textContent = topPlayers.length >= 2 ? `#2 ${topPlayers[1].nombre}: ${topPlayers[1].puntos}` : '';
if (topPlayers[1] && topPlayers[1].color) {textLine2.style.fill = topPlayers[1].color; } else {}
textLine3.textContent = topPlayers.length >= 3 ? `#3 ${topPlayers[2].nombre}: ${topPlayers[2].puntos}` : '';
if (topPlayers[2] && topPlayers[2].color) {textLine3.style.fill = topPlayers[2].color; } else {}
textLine4.textContent = topPlayers.length >= 4 ? `#4 ${topPlayers[3].nombre}: ${topPlayers[3].puntos}` : '';
if (topPlayers[3] && topPlayers[3].color) {textLine4.style.fill = topPlayers[3].color; } else {}
textLine5.textContent = topPlayers.length >= 5 ? `#5 ${topPlayers[4].nombre}: ${topPlayers[4].puntos}` : '';
if (topPlayers[4] && topPlayers[4].color) {textLine5.style.fill = topPlayers[4].color; } else {}
});	

//7. GET TOP PLAYERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
function getTopPlayers() {
const sortedPlayers = topplayers.sort((a, b) => b.puntos - a.puntos);
const topPlayersx = sortedPlayers.slice(0, 5);
topPlayersx.forEach(topplayer => { });
return topPlayersx;
}	

//8. GENERA CIRCULOS VERDES DEL SERVER !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////

let greenCircles = [];
let greenCircles2 = [];
// Manejar el evento 'greenCirclesGenerated' para actualizar los círculos verdes
socket.on('greenCirclesGenerated', (circles) => {
console.log('GREEN CIRCLES GENERATED.');
greenCircles = [];
greenCircles2 = [];
greenCircles.push(...circles);
console.log(`GreenCircles LENGTH: ${greenCircles.length}:`);
generateGreenCircles();
});	
	
function generateGreenCircles() {
console.log('GENERATE GREEN CIRCLES 2.');
const svg = document.querySelector('svg');
const hexagons = document.querySelectorAll('#hexagonGroup polygon');
// Borra los círculos verdes existentes
document.querySelectorAll('circle[fill="green"]').forEach(circle => {
circle.parentNode.removeChild(circle);
});
let i = 0;
// Dibuja los círculos verdes en las coordenadas recibidas del servidor
greenCircles.forEach(({ x, y }) => {
	i+=1;
console.log(`${i}: ${x}, ${y}`);
const greenCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
greenCircle.setAttribute('cx', x);
greenCircle.setAttribute('cy', y);
greenCircle.setAttribute('r', '8');
greenCircle.setAttribute('fill', 'green');
//greenCircle.setAttribute('data-index', i); // Asigna un índice único
greenCircle.setAttribute('id', 'greenCircle_' + i); // Asignar un ID único
	
//svg.appendChild(greenCircle);
const cameraGroup = document.getElementById('camera'); 
cameraGroup.appendChild(greenCircle);
//ANIMACION CIRCULO VERDE
anime({ targets: greenCircle, r: 6,
duration: 1000, easing: 'easeInOutSine',
direction: 'alternate', loop: true });
greenCircles2.push({ x, y, index: i });

});
//socket.emit('greenCirclesGenerated', greenCircles);
}

//9. UPDATE PLAYERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
socket.on('updatePlayers', function (updatedPlayers) {
console.log('SOCKET UPDATE PLAYERS');
//Iterar sobre el objeto de jugadores y actualizar la información
for (const playerId in updatedPlayers) {
const player = updatedPlayers[playerId];

//PLAYER ELEMENT 
const existingPlayerElement = document.getElementById(playerId);
if (existingPlayerElement) {
	existingPlayerElement.setAttribute('cx', player.x);
	existingPlayerElement.setAttribute('cy', player.y);
	const sizeCalc = player.puntos * 0.1;
	existingPlayerElement.setAttribute('r', 9 + sizeCalc * 10);
} else {		
	const playerElement = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
	const sizeCalc = player.puntos * 0.1;
	playerElement.setAttribute('id', playerId);
	playerElement.setAttribute('r', 9+ sizeCalc * 10);
	playerElement.setAttribute('fill', player.color);
	playerElement.setAttribute('cx', player.x);
	playerElement.setAttribute('cy', player.y);
	hexagonGroup.appendChild(playerElement);	
	}

//TEXT ELEMENT
const existingTextElement = document.getElementById(playerId + '-name');
if (existingTextElement) {
	existingTextElement.setAttribute('x', player.x);
	existingTextElement.setAttribute('y', player.y - 8);
	existingTextElement.textContent = player.nombre + ' ('+ player.puntos + ')';
} else {
	const textElement2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
	textElement2.setAttribute('id', playerId + '-name');
	textElement2.setAttribute('x', player.x);
	textElement2.setAttribute('y', player.y - 10);
	textElement2.setAttribute('text-anchor', 'middle');
	textElement2.setAttribute('fill', 'green');
	textElement2.setAttribute('font-size', '16px');
	textElement2.textContent = player.nombre + ' ('+ player.puntos + ')';
	hexagonGroup.appendChild(textElement2);
	}
}
});

//WHEN MOVE FUNCTIONS```````````````````````````````````````````````````-------------------------------------------------
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!-------------------------------------------------
//WHEN MOVE FUNCTIONS```````````````````````````````````````````````````-------------------------------------------------
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!-------------------------------------------------
//WHEN MOVE FUNCTIONS```````````````````````````````````````````````````-------------------------------------------------
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!-------------------------------------------------
//WHEN MOVE FUNCTIONS```````````````````````````````````````````````````-------------------------------------------------
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!-------------------------------------------------

//1. MOVE BLUE POINT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////////
	
function moveBluePoint( clickX, clickY ) {

//CAMARA/////////////////////
const transformAttribute = camera.getAttribute('transform');
const match = transformAttribute.match(/translate\(([^,]+),([^,]+)\)/);
if (match) {
currentCameraX4 = parseFloat(match[1]);
currentCameraY4 = parseFloat(match[2]);
//console.log('Coordenadas cámara:', currentCameraX4, currentCameraY4);  
} else { console.error('No cámara.'); }
//CAMARA END/////////////////////
	
if (!isMoving) { 
console.log('/////Move Player//////')
isMoving = true;  
drawUserCount();

const closestGreenVertex = findClosestGreenVertexToClick(clickX - currentCameraX4, clickY - currentCameraY4); 
//console.log('Vértice cercano: ', closestGreenVertex.x, closestGreenVertex.y); 
animateBluePoint(closestGreenVertex.x, closestGreenVertex.y);
		
}
	
}	

//2. FIND CLOSES VERTEX TO CLICK!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////

function findClosestGreenVertexToClick(x, y) {
const greenVertices = document.querySelectorAll('circle[fill="red"]');
let closestVertex = null; let minDistance = Infinity;
greenVertices.forEach((greenVertex) => {
const x1 = parseFloat(greenVertex.getAttribute('cx')) - currentCameraX3; 
const y1 = parseFloat(greenVertex.getAttribute('cy')) - currentCameraY3; 
const distance = pointToPointDistance2(x, y, x1, y1);
if (distance < minDistance) {
minDistance = distance; closestVertex = { x: x1, y: y1 }; }
});
return closestVertex;
}	
function pointToPointDistance2(x1, y1, x2, y2) {
const dx = x1 - x2;
const dy = y1 - y2;
return Math.sqrt(dx * dx + dy * dy);
}

//3. ANIMATE BLUE POINT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
/////////////////////////////////////////////////////////////////////////////	

function animateBluePoint(destinationX, destinationY) {
console.log('1. Animate Blue Point');
//const startX = parseFloat(bluePointElement.getAttribute('cx'));
//const startY = parseFloat(bluePointElement.getAttribute('cy'));
const startX = bX;
const startY = bY;
const startTime = performance.now();
const duration = 50; // 1 seg
function update() {
const currentTime = performance.now();
const elapsed = currentTime - startTime;
const progress = Math.min(elapsed / duration, 1);
const newX = startX + progress * (destinationX - startX);
const newY = startY + progress * (destinationY - startY);
		
//bluePointElement.setAttribute('cx', newX);
//bluePointElement.setAttribute('cy', newY);
bX = newX;
bY = newY;	
		
if (progress < 1) { requestAnimationFrame(update);
} else {
// Animación completada, emitir datos al servidor
socket.emit('animationData', { start: { x: startX, y: startY }, end: { x: newX, y: newY } });
// Supongamos que newPosition es un objeto con las nuevas coordenadas
const newPosition = { x:  newX , y: newY };
socket.emit('updatePosition', newPosition);
inicialX = newX; inicialY = newY;
//console.log(`NUEVAS COORDS (${inicialX}, ${inicialY}).`);
	
//detectarColisiones(bluePointElement);
//handleCollisionWithGreenCircle(newX, newY);

	//console.log(`GreenCirclesLength: ${greenCircles.length}`);
	//console.log(`GreenCircles1: ${greenCircles[1].x},${greenCircles[1].y}`);

	
}
} requestAnimationFrame(update);
}		

//4. SOCKET ANIMATE BLUE POINT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
socket.on('animateBluePoint', function (animationData) {
//console.log('SOCKET ANIMATE BLUE POINT');
const playerId = animationData.playerId;
const data = animationData.data;
const txt = animationData.playerName;
// Encuentra el círculo correspondiente al jugador
const playerElement = document.getElementById(playerId);
const textElement2 = document.getElementById(playerId + '-name');

//console.log('PLAYER ID MOVE:', playerElement);  
//console.log('PLAYER ID MOVE2:', playerId);  

animateCircleLocally(playerElement, data.start, data.end, playerId);
animateNameLocally(textElement2, data.start, data.end);

//FINISCHED ANIMATE CIRCLE LOCALLY !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	
animateCircleLocally(playerElement, data.start, data.end, playerId, function() {
	console.log('La animación ha terminado');
	findAndMarkClosestVertices();
	isMoving = false;
	});
});	


//5. ANIMATE CIRCLE LOCALLY !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
			  
function animateCircleLocally(circleElement, start, end, playerId, callback) {
//console.log('ANIMATE CIRCLE LOCALLY');
const duration = 200;
const startTime = performance.now();
function update() {
const currentTime = performance.now();
const progress = Math.min((currentTime - startTime) / duration, 1);
const newX = start.x + progress * (end.x - start.x);
const newY = start.y + progress * (end.y - start.y);
		
circleElement.setAttribute('cx', newX);
circleElement.setAttribute('cy', newY);
		//console.log(`RADIO circleElement:`, circleElement.getAttribute('r'));


//detectarColisionesConCirculosVerdes(newX, newY, 12, circleElement );	
detectarColisionesRectangulares(newX, newY, circleElement.getAttribute('r') , greenCircles2 );
	

////CAMERA MOVEMENT
if (socket.id===playerId) {
	const newXCam = svgWidth / 2 - newX;
	const newYCam = svgHeight / 2 - newY;	
	camera.setAttribute('transform', `translate(${newXCam}, ${newYCam})`);
}
////END CAMERA MOVEMENT
		
if (progress < 1) { requestAnimationFrame(update); } 
else {
// La animación ha terminado
if (typeof callback === 'function') { callback(); } 

	

//detectarColisiones(circleElement);
//handleCollisionWithGreenCircle(newX, newY);	

  /*const greenVertices = document.querySelectorAll('circle[fill="green"]');
    greenVertices.forEach((greenVertex) => {
        if (detectarColisionesGenerales(circleElement, greenVertex)) {
	console.log(`COLISION DETECTADA verde.`);
	
            // Manejar la colisión, por ejemplo, eliminar el círculo verde
            greenVertex.parentNode.removeChild(greenVertex);

		socket.emit('greenCircleEaten');
	
            // Realizar otras acciones necesarias
        }
    });	*/


	
}	
} requestAnimationFrame(update);
	
}

	
//6. ANIMATE TEXT NAME !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
function animateNameLocally(circleElement, start, end) {
//console.log('ANIMATE TEXT LOCALLY');
const duration = 100;
const startTime = performance.now();
function update() {
const currentTime = performance.now();
const progress = Math.min((currentTime - startTime) / duration, 1);
const newX = start.x + progress * (end.x - start.x);
const newY = start.y + progress * (end.y - start.y);
	
circleElement.setAttribute('x', newX);
circleElement.setAttribute('y', newY - 8);

if (progress < 1) {
requestAnimationFrame(update); } }
requestAnimationFrame(update);
	
}	

//7. MARK RED VERTEX NEAR!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
function findAndMarkClosestVertices() {
clearAllGreenCircles();
const currentX = inicialX - currentCameraX3;
const currentY = inicialY - currentCameraY3;
// Encuentra los vértices en un radio de 60 pixeles
const closestVertices = findVerticesInRadius(currentX, currentY, 60);
// Agrega un círculo verde en cada vértice encontrado
closestVertices.forEach((vertex) => {
markVertexWithGreenCircle(vertex.x + currentCameraX3, vertex.y + currentCameraY3);
});
}
	
function clearAllGreenCircles() {
const svg = document.querySelector('svg');
const greenCircles = document.querySelectorAll('circle[fill="red"]');
greenCircles.forEach((greenCircle) => { 
const cameraGroup = document.getElementById('camera');
cameraGroup.removeChild(greenCircle); }); 
}	
	
function findVerticesInRadius(x, y, radius) {
const hexagons = document.querySelectorAll('#hexagonGroup polygon');
const result = [];
hexagons.forEach((hexagon) => {
const points = hexagon.getAttribute('points').split(' ');
// Iteramos sobre los vértices del hexágono
for (let i = 0; i < points.length; i++) {
const [x1, y1] = points[i].split(',').map(Number);
// Calculamos la distancia entre el punto azul y el vértice
const distance = pointToPointDistance2(x, y, x1, y1);
// Agregamos el vértice si está dentro del radio especificado
if (distance < radius) {
result.push({ x: x1, y: y1 }); } } });
return result;
}

function markVertexWithGreenCircle(x, y) { 
const svg = document.querySelector('svg'); 
const greenCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); 
greenCircle.setAttribute('cx', x); 
greenCircle.setAttribute('cy', y); 
greenCircle.setAttribute('r', '3'); 
greenCircle.setAttribute('fill', 'red');
//console.log(`Verde agreg: (${x}, ${y}) marcado con círculo rojo.`);
const cameraGroup = document.getElementById('camera'); cameraGroup.appendChild(greenCircle);
}
	

//8. DETECTAR COLISION !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
function detectarColisiones(playerElement) {
const blueX = parseFloat(playerElement.getAttribute('cx'));
const blueY = parseFloat(playerElement.getAttribute('cy'));
const blueRadius = 9; // Radio del círculo azul (jugador)

//COLISION DETECTAR JUGADORES!!!!!!!!!!!!!!!!!!
	
document.querySelectorAll('circle').forEach((otherCircle) => {
console.log('COLISION DETECTADA.');
	
const playerIdN = otherCircle.getAttribute('id');
console.log(`COLISION ID: (${playerIdN})`); 
	
if (playerIdN !== socket.id && playerIdN !== null && playerIdN !== 'bluePoint') {
const greenX = parseFloat(otherCircle.getAttribute('cx'));
const greenY = parseFloat(otherCircle.getAttribute('cy'));
	
console.log(`Colision con: (${playerIdN})`); 
console.log(`SOCKET ID: (${socket.id})`); 

//console.log(`RADIO playerE: (${ playerElement })`);

console.log(`RADIO tuyo: (${ radioJugador+9  })`); 

console.log(`RADIO enemigo: (${ otherCircle.getAttribute('r')   })`); 

let radioEnemigo = otherCircle.getAttribute('r');

if (radioJugador > radioEnemigo){ 
console.log(`HAS COMIDO AL OTRO JUGADOR`); 
}else if (radioJugador < radioEnemigo){
console.log(`GAME OVER`); 
}

// Obtener los radios de los círculos
const greenRadius = parseFloat(otherCircle.getAttribute('r'));
// Calcular las coordenadas de los cuadros delimitadores
const blueBoundingBox = {
x1: blueX - blueRadius, y1: blueY - blueRadius,
x2: blueX + blueRadius, y2: blueY + blueRadius };
const greenBoundingBox = {
x1: greenX - greenRadius, y1: greenY - greenRadius,
x2: greenX + greenRadius, y2: greenY + greenRadius};
// Verificar la colisión entre los cuadros delimitadores
if (blueBoundingBox.x1 < greenBoundingBox.x2 &&
blueBoundingBox.x2 > greenBoundingBox.x1 &&
blueBoundingBox.y1 < greenBoundingBox.y2 &&
blueBoundingBox.y2 > greenBoundingBox.y1 ) {
// Eliminar el círculo verde del SVG
//otherCircle.parentNode.removeChild(otherCircle);
console.log('Colisión detectada. Círculo verde eliminado.');
//socket.emit('greenCircleEaten');
}}});
console.log('La detección de colisiones ha terminado.');
}


//9. COLISION CON CIRCULOS VERDES !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//////////////////////////////////////////////////////////////////////
	
function handleCollisionWithGreenCircle(playerX, playerY) {
// Verificar colisión con cada círculo verde
for (const circle of greenCircles2) {
const distance = Math.sqrt((playerX - circle.x) ** 2 + (playerY - circle.y) ** 2);
//console.log(`COLISION distance: ${distance}:`);
if (distance < 10) {
console.log(`COLISION Index: ${circle.index}:`);
// Emitir evento al servidor indicando el índice del círculo verde colisionado
socket.emit('collisionWithGreenCircle', circle.index);
socket.emit('greenCircleEaten');
break; // No es necesario verificar más círculos
} }
}


////////////////////////////////////////////////////////////	
//YELLOW POINTS CERCA DE LINEAS !!!!!!!!!!!!!!!!!!
////////////////////////////////////////////////////////////
	
// Función para calcular las líneas que forman los hexágonos
function calculateHexagonLines() {
const hexagons = document.querySelectorAll('#hexagonGroup polygon');
const hexagonLines = [];
hexagons.forEach(hexagon => {
const points = hexagon.getAttribute('points').split(' ');
// Iterar sobre los vértices del hexágono
for (let i = 0; i < points.length; i++) {
const [x1, y1] = points[i].split(',').map(Number);
const [x2, y2] = points[(i + 1) % points.length].split(',').map(Number);
hexagonLines.push({ x1, y1, x2, y2 }); } });
return hexagonLines;
}	
// Función para dibujar 100 puntos amarillos aleatorios en las líneas de los hexágonos
function drawRandomYellowPointsOnHexLines() {
const svg = document.querySelector('svg');
const hexagonLines = calculateHexagonLines();
for (let i = 0; i < 100; i++) {
// Elegir aleatoriamente una línea de los hexágonos
const randomLine = hexagonLines[Math.floor(Math.random() * hexagonLines.length)];
// Calcular una posición aleatoria a lo largo de la línea
const randomX = Math.random() * (randomLine.x2 - randomLine.x1) + randomLine.x1;
const randomY = Math.random() * (randomLine.y2 - randomLine.y1) + randomLine.y1;
// Crear un círculo amarillo en la posición aleatoria
const yellowDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
yellowDot.setAttribute('cx', randomX); yellowDot.setAttribute('cy', randomY);
yellowDot.setAttribute('r', '2'); yellowDot.setAttribute('fill', 'yellow');
const cameraGroup = document.getElementById('camera'); cameraGroup.appendChild(yellowDot); }
}
//drawRandomYellowPointsOnHexLines();	

////////////////////////////////////////////////////////////
///NUEVAS PRUEBAS !!!!!!!!!
/*
function detectarColisionesGenerales(elemento1, elemento2) {
	
    const x1 = parseFloat(elemento1.getAttribute('cx'));
    const y1 = parseFloat(elemento1.getAttribute('cy'));
    const radio1 = parseFloat(elemento1.getAttribute('r'));

    const x2 = parseFloat(elemento2.getAttribute('cx'));
    const y2 = parseFloat(elemento2.getAttribute('cy'));
    const radio2 = parseFloat(elemento2.getAttribute('r'));

    const distancia = Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);


    return distancia < radio1 + radio2+20;
}
*/

//DETECTAR COLISION CON CIRCULOS VERDES !!!!!!!!!!!!!!!!!!
////////////////////////////////////////////////////////////	
	
function detectarColisionesRectangulares(blueX, blueY, blueRadius, greenCircles) {
for (const circle of greenCircles) {
const greenX = circle.x;
const greenY = circle.y;
//const greenRadius = circle.radius;
const greenRadius = 8;
const greenIndex = circle.index;
// Calcular las coordenadas de los rectángulos delimitadores
const blueBoundingBox = {
x1: blueX - blueRadius, y1: blueY - blueRadius,
x2: blueX + blueRadius, y2: blueY + blueRadius };
const greenBoundingBox = {
x1: greenX - greenRadius, y1: greenY - greenRadius,
x2: greenX + greenRadius, y2: greenY + greenRadius };

// Verificar la colisión entre los rectángulos delimitadores
if (blueBoundingBox.x1 < greenBoundingBox.x2 && blueBoundingBox.x2 > greenBoundingBox.x1 &&
blueBoundingBox.y1 < greenBoundingBox.y2 && blueBoundingBox.y2 > greenBoundingBox.y1) {
console.log(`COLISION Detectada`);



/////	

console.log(`COLISION Index: ${greenIndex}:`);	
const circleToRemoveC = document.getElementById('greenCircle_'+greenIndex);
console.log(`Circle TO REMOVE !!!!!!`, circleToRemoveC);
if (circleToRemoveC) {
    circleToRemoveC.parentNode.removeChild(circleToRemoveC);
}
const indexToRemove = greenCircles.indexOf(circle);
// Elimina el círculo del array usando splice
if (indexToRemove !== -1) {
//greenCircles.splice(indexToRemove, 1);
//socket.emit('collisionWithGreenCircle2', circle.index);
socket.emit('greenCircleEaten');		    
}




	
// Colisión detectada
return true;
}
}
//console.log(`NO COLISION`);
// No hay colisión
return false;
}


//MANDAR COLISION A TODOS ELIMINAR CIRCULO VERDE !!!!!!!!!!!!!!!!!!
////////////////////////////////////////////////////////////	

socket.on('greenCircleCollision', (collisionIndex) => {
console.log(`collisionWithGreenCircle2!!!!!!`);	
const circleToRemove = document.getElementById('greenCircle_1'); // ID del círculo a eliminar
if (circleToRemove) {
console.log(`Circle getElementById!!!!!!`, circleToRemove);	
// circleToRemove.parentNode.removeChild(circleToRemove);
}	
// Seleccionar el círculo verde colisionado por su índice y eliminarlo del DOM
const greenCircleElement = document.querySelector(`#camera circle:nth-child(${collisionIndex})`);
if (greenCircleElement) {
console.log(`collisionWithGreenCircle2!!!!!!`, greenCircleElement);	
//const index = greenCircleElement.getAttribute('data-index');
//  	  console.log(`Circle index!!!!!!`, index);	    
//greenCircleElement.parentNode.removeChild(greenCircleElement);
}
});
	

/*
	function detectarColisionesConCirculosVerdes(blueX, blueY, blueRadius, jugador) {
   
    document.querySelectorAll('circle[fill="green"]').forEach((otroCirculo) => {
        const greenX = parseFloat(otroCirculo.getAttribute('cx'));
        const greenY = parseFloat(otroCirculo.getAttribute('cy'));
        const greenRadius = parseFloat(otroCirculo.getAttribute('r'));

        if (hayColision(blueX, blueY, blueRadius, greenX, greenY, greenRadius)) {
            manejarColisionConCirculoVerde(jugador, otroCirculo);
        }
    });
}

function hayColision(blueX, blueY, blueRadius, greenX, greenY, greenRadius) {
    const distancia = Math.sqrt((blueX - greenX) ** 2 + (blueY - greenY) ** 2);
    return distancia < blueRadius + greenRadius;
}

function manejarColisionConCirculoVerde(jugador, circuloVerde) {
    // Acciones a realizar cuando hay una colisión con un círculo verde
    // Ejemplo: Eliminar el círculo verde del SVG
    circuloVerde.parentNode.removeChild(circuloVerde);

    // Aquí puedes agregar más acciones según tus necesidades
}

*/


/*
function detectarColisionesRectangulares2(blueX, blueY, blueRadius, greenCircles) {
    for (const [index, circle] of greenCircles.entries()) {


        const greenX = circle.x;
        const greenY = circle.y;
        //const greenRadius = circle.radius;
        const greenRadius = 8;
            const greenIndex = circle.index;

        // Calcular las coordenadas de los rectángulos delimitadores
        const blueBoundingBox = {
            x1: blueX - blueRadius,
            y1: blueY - blueRadius,
            x2: blueX + blueRadius,
            y2: blueY + blueRadius
        };
        const greenBoundingBox = {
            x1: greenX - greenRadius,
            y1: greenY - greenRadius,
            x2: greenX + greenRadius,
            y2: greenY + greenRadius
        };


        // Resto del código de detección de colisiones...

        if (blueBoundingBox.x1 < greenBoundingBox.x2 &&
            blueBoundingBox.x2 > greenBoundingBox.x1 &&
            blueBoundingBox.y1 < greenBoundingBox.y2 &&
            blueBoundingBox.y2 > greenBoundingBox.y1) {
            
            console.log(`COLISION Detectada`);

            // Eliminar el círculo verde del DOM
            const circleToRemove = document.getElementById(`circle-${circle.index}`);
            if (circleToRemove) {
                circleToRemove.remove();
            }

            // Eliminar el círculo verde de la lista
            greenCircles.splice(index, 1);

            // Colisión detectada
            return true;
        }
    }
    console.log(`NO COLISION`);
    // No hay colisión
    return false;
}

*/

/////////////////////////////////////////////////////////////
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
//END DOM	 
});
//END DOM
	
</script>
  
</body>
</html>
